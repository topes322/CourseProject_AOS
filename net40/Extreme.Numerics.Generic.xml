<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>Extreme.Numerics.Generic</name>
  </assembly>
  <members>
    <member name="T:Extreme.Mathematics.GenericCoreProvider`1">
      <summary>
            Represents a managed provider for the core linear algebra and FFT functionality 
            for an element type.
            </summary>
    </member>
    <member name="M:Extreme.Mathematics.GenericCoreProvider`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Extreme.Providers.ManagedCoreProvider" />.
            </summary>
    </member>
    <member name="P:Extreme.Mathematics.GenericCoreProvider`1.ArrayFunctions">
      <summary>
            Gets or sets the current implementation of array functions
            for double-precision arguments.
            </summary>
    </member>
    <member name="P:Extreme.Mathematics.GenericCoreProvider`1.ComplexArrayFunctions">
      <summary>
            Gets or sets the current implementation of array functions
            for double-precision arguments.
            </summary>
    </member>
    <member name="P:Extreme.Mathematics.GenericCoreProvider`1.DecompositionOperations">
      <summary>
            Gets the LAPACK implementation
            for T-precision arguments.
            </summary>
    </member>
    <member name="P:Extreme.Mathematics.GenericCoreProvider`1.Fft">
      <summary>
            Gets or sets the current FFT provider implementation
            for T-precision arguments.
            </summary>
    </member>
    <member name="M:Extreme.Mathematics.GenericCoreProvider`1.GetAllImplementations``1">
      <summary>
            Returns a sequence of all implementations of the specified type
            supported by the provider.
            </summary>
      <typeparam name="U">The type of the implementation.</typeparam>
      <returns>A sequence of all implementations of type <typeparamref name="U" />
            supported by the provider.</returns>
    </member>
    <member name="P:Extreme.Mathematics.GenericCoreProvider`1.HasSharedDegreeOfParallelism">
      <summary>
            Indicates whether the degree of parallelism is a property that is shared
            across instances.
            </summary>
    </member>
    <member name="P:Extreme.Mathematics.GenericCoreProvider`1.LinearAlgebraOperations">
      <summary>
            Gets the implementation of the 
            BLAS for T-precision arguments.
            </summary>
    </member>
    <member name="P:Extreme.Mathematics.GenericCoreProvider`1.SparseLinearAlgebra">
      <summary>
            Gets the implementation of the sparse
            BLAS for T-precision arguments.
            </summary>
    </member>
    <member name="M:Extreme.Mathematics.GenericCoreProvider`1.WithMaxDegreeOfParallelism(System.Int32)">
      <summary>
            Returns a provider with the specified maximum degree of parallelism.
            </summary>
      <param name="maxDegreeOfParallelism">The maximum degree of parallelism.</param>
      <returns>A <see cref="T:Extreme.Providers.ManagedCoreProvider" /> with the specified
            maximum degree of parallelism.</returns>
    </member>
    <member name="T:Extreme.Mathematics.GenericImplementations"></member>
    <member name="M:Extreme.Mathematics.GenericImplementations.RegisterGenericProvider(Extreme.Providers.ProviderManager)">
      <summary>
            Registers the provider of generic implementations of linear
            algebra functions.
            </summary>
      <param name="providerManager"></param>
    </member>
    <member name="T:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1">
      <summary>
            Specifies the methods that must be implemented by a
            class to support complex T-precision LAPACK routines
            for general matrices.
            </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandCholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
        <para>
            Computes the Cholesky factorization of a complex Hermitian
            positive definite band matrix A.</para>
      </summary>
      <param name="uplo">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            On entry, the upper or lower triangle of the Hermitian band
            matrix A, stored in the first KD+1 rows of the array.  The
            j-th column of A is stored in the j-th column of the array AB
            as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
            On exit, if <paramref name="info" /> = 0, the triangular factor U or L from the
            Cholesky factorization A = U<sup>H</sup>*U or A = L*L<sup>H</sup> of the band
            matrix A, in the same storage format as A.
            </pre>
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            &gt; 0:  if <paramref name="info" /> = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandCholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
      <summary>
        <para>
            Computes the Cholesky factorization of a real symmetric
            positive definite band matrix A.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            Dimension (LDAB,N)
            On entry, the upper or lower triangle of the symmetric band
            matrix A, stored in the first KD+1 rows of the array.  The
            j-th column of A is stored in the j-th column of the array AB
            as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
            On exit, if <paramref name="info" /> = 0, the triangular factor U or L from the
            Cholesky factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup> of the band
            matrix A, in the same storage format as A.
            </pre>
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            &gt; 0:  if <paramref name="info" /> = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandCholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0,`0@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a complex Hermitian positive definite band matrix using
            the Cholesky factorization A = U<sup>H</sup>*U or A = L*L<sup>H</sup> computed by
            ZPBTRF.</para>
      </summary>
      <param name="uplo">
        <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of sub-diagonals if UPLO = 'L'.  KD &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>H</sup>*U or A = L*L<sup>H</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="anorm">
        <pre>
            The 1-norm (or infinity-norm) of the Hermitian band matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandCholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},`0,`0@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a real symmetric positive definite band matrix using the
            Cholesky factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup> computed by DPBTRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            Dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="aNorm">
        <pre>
            The 1-norm (or infinity-norm) of the symmetric band matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandCholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations A*X = B with a Hermitian
            positive definite band matrix A using the Cholesky factorization
            A = U<sup>H</sup> *U or A = L*L<sup>H</sup> computed by ZPBTRF.</para>
      </summary>
      <param name="uplo">
        <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>H</sup> *U or A = L*L<sup>H</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="b">
        <pre>
            B is COMPLEX*16 array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandCholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations A*X = B with a symmetric
            positive definite band matrix A using the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup> computed by DPBTRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            Dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="b">
        <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandLUDecompose(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes an LU factorization of a complex m-by-n band matrix A
            using partial pivoting with row interchanges.</para>
      </summary>
      <param name="m">
        <pre>
            The number of rows of the matrix A.  M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kl">
        <pre>
            The number of subdiagonals within the band of A.  KL &gt;= 0.
            </pre>
      </param>
      <param name="ku">
        <pre>
            The number of superdiagonals within the band of A.  KU &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            On entry, the matrix A in band storage, in rows KL+1 to
            2*KL+KU+1; rows 1 to KL of the array need not be set.
            The j-th column of A is stored in the j-th column of the
            array AB as follows:
            AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)
            On exit, details of the factorization: U is stored as an
            upper triangular band matrix with KL+KU superdiagonals in
            rows 1 to KL+KU+1, and the multipliers used during the
            factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
            See below for further details.
            </pre>
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (min(M,N))
            The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0: successful exit
            &lt; 0: if <paramref name="info" /> = -i, the i-th argument had an illegal value
            &gt; 0: if <paramref name="info" /> = +i, U(i,i) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandLUDecompose(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes an LU factorization of a real m-by-n band matrix A
            using partial pivoting with row interchanges.</para>
      </summary>
      <param name="m">
        <pre>
            The number of rows of the matrix A.  M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kl">
        <pre>
            The number of subdiagonals within the band of A.  KL &gt;= 0.
            </pre>
      </param>
      <param name="ku">
        <pre>
            The number of superdiagonals within the band of A.  KU &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            Dimension (LDAB,N)
            On entry, the matrix A in band storage, in rows KL+1 to
            2*KL+KU+1; rows 1 to KL of the array need not be set.
            The j-th column of A is stored in the j-th column of the
            array AB as follows:
            AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)
            On exit, details of the factorization: U is stored as an
            upper triangular band matrix with KL+KU superdiagonals in
            rows 1 to KL+KU+1, and the multipliers used during the
            factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
            See below for further details.
            </pre>
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (min(M,N))
            The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0: successful exit
            &lt; 0: if <paramref name="info" /> = -i, the i-th argument had an illegal value
            &gt; 0: if <paramref name="info" /> = +i, U(i,i) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandLUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},`0,`0@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number of a complex
            general band matrix A, in either the 1-norm or the infinity-norm,
            using the LU factorization computed by ZGBTRF.</para>
      </summary>
      <param name="norm">
        <pre>
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kl">
        <pre>
            The number of subdiagonals within the band of A.  KL &gt;= 0.
            </pre>
      </param>
      <param name="ku">
        <pre>
            The number of superdiagonals within the band of A.  KU &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by ZGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="anorm">
        <pre>
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0: if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandLUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},`0,`0@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number of a real
            general band matrix A, in either the 1-norm or the infinity-norm,
            using the LU factorization computed by DGBTRF.</para>
      </summary>
      <param name="norm">
        <pre>
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kl">
        <pre>
            The number of subdiagonals within the band of A.  KL &gt;= 0.
            </pre>
      </param>
      <param name="ku">
        <pre>
            The number of superdiagonals within the band of A.  KU &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            Dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by DGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="anorm">
        <pre>
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0: if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandLUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations
               A * X = B,  A<sup>T</sup> * X = B,  or  A<sup>H</sup> * X = B
            with a general band matrix A using the LU factorization computed
            by ZGBTRF.</para>
      </summary>
      <param name="trans">
        <pre>
            Specifies the form of the system of equations.
            = 'N':  A * X = B     (No transpose)
            = 'T':  A<sup>T</sup> * X = B  (Transpose)
            = 'C':  A<sup>H</sup> * X = B  (Conjugate transpose)
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kl">
        <pre>
            The number of subdiagonals within the band of A.  KL &gt;= 0.
            </pre>
      </param>
      <param name="ku">
        <pre>
            The number of superdiagonals within the band of A.  KU &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by ZGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is COMPLEX*16 array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandLUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{`0},System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations
               A * X = B  or  A<sup>T</sup> * X = B
            with a general band matrix A using the LU factorization computed
            by DGBTRF.</para>
      </summary>
      <param name="trans">
        <pre>
            Specifies the form of the system of equations.
            = 'N':  A * X = B  (No transpose)
            = 'T':  A<sup>T</sup>* X = B  (Transpose)
            = 'C':  A<sup>T</sup>* X = B  (Conjugate transpose = Transpose)
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kl">
        <pre>
            The number of subdiagonals within the band of A.  KL &gt;= 0.
            </pre>
      </param>
      <param name="ku">
        <pre>
            The number of superdiagonals within the band of A.  KU &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            Dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by DGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= 2*KL+KU+1.
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="b">
        <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0: if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandTriangularSolve(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
      <summary>
        <para>
            Solves a triangular system of the form
               A * X = B  or  A<sup>T</sup> * X = B,
            where A is a triangular band matrix of order N, and B is an
            N-by NRHS matrix.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </pre>
      </param>
      <param name="trans">
        <pre>
            Specifies the form the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A<sup>T</sup> * X = B  (Transpose)
            = 'C':  A<sup>H</sup> * X = B  (Conjugate transpose = Transpose)
            </pre>
      </param>
      <param name="diag">
        <pre>
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="kd">
        <pre>
            The number of superdiagonals or subdiagonals of the
            triangular band matrix A.  KD &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="ab">
        <pre>
            Dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first kd+1 rows of AB.  The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
            If DIAG = 'U', the diagonal elements of A are not referenced
            and are assumed to be 1.
            </pre>
        <pre>
            The leading dimension of the array AB.  LDAB &gt;= KD+1.
            </pre>
      </param>
      <param name="b">
        <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, if <paramref name="info" /> = 0, the solution matrix X.
            </pre>
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            &gt; 0:  if <paramref name="info" /> = i, the i-th diagonal element of A is zero,
                  indicating that the matrix is singular and the
                  solutions X have not been computed.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
            Factors a symmetric positive definite matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
      <summary>
        <para>
            Computes the Cholesky factorization of a real symmetric
            positive definite matrix A.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if <paramref name="info" /> = 0, the factor U or L from the Cholesky
            factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup>.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            &gt; 0:  if <paramref name="info" /> = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0,`0@,System.Int32@)">
      <summary>
            Estimates the reciprocal of the condition number of a factored hermitian matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="aNorm">The norm of the matrix.</param>
      <param name="rcond">On return, an estimate for the reciprocal of the condition number of the matrix.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},`0,`0@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a real symmetric positive definite matrix using the
            Cholesky factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup> computed by DPOTRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup>, as computed by DPOTRF.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="anorm">
        <pre>
            The 1-norm (or infinity-norm) of the symmetric matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskyInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
            Computes the inverse of a factored hermitian matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskyInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
      <summary>
        <para>
            Computes the inverse of a real symmetric positive definite
            matrix A using the Cholesky factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup>
            computed by DPOTRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            On entry, the triangular factor U or L from the Cholesky
            factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup>, as computed by
            DPOTRF.
            On exit, the upper or lower triangle of the (symmetric)
            inverse of A, overwriting the input factor U or L.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            &gt; 0:  if <paramref name="info" /> = i, the (i,i) element of the factor U or L is
                  zero, and the inverse could not be computed.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
            Solves a hermitian system of equations.
            </summary>
      <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle" /> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="nrhs">The number of right hand sides.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="b">A complex array that contains the components of the right-hand side(s).</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations A*X = B with a symmetric
            positive definite matrix A using the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup> computed by DPOTRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup>, as computed by DPOTRF.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="b">
        <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.EigenvalueDecompose(System.Char,System.Char,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
        <para>
            Computes for an N-by-N complex non-symmetric matrix A, the
            eigenvalues and, optionally, the left and/or right eigenvectors.</para>
      </summary>
      <param name="jobvl">
        <pre>
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of are computed.
            </pre>
      </param>
      <param name="jobvr">
        <pre>
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A. N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="w">
        <pre>
            W is COMPLEX*16 array, dimension (N)
            W contains the computed eigenvalues.
            </pre>
      </param>
      <param name="vl">
        <pre>
            VL is COMPLEX*16 array, dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            u(j) = VL(:,j), the j-th column of VL.
            </pre>
        <pre>
            The leading dimension of the array VL.  LDVL &gt;= 1; if
            JOBVL = 'V', LDVL &gt;= N.
            </pre>
      </param>
      <param name="vr">
        <pre>
            VR is COMPLEX*16 array, dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = 'N', VR is not referenced.
            v(j) = VR(:,j), the j-th column of VR.
            </pre>
        <pre>
            The leading dimension of the array VR.  LDVR &gt;= 1; if
            JOBVR = 'V', LDVR &gt;= N.
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value.
            &gt; 0:  if <paramref name="info" /> = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors have been computed;
                  elements and i+1:N of W contain eigenvalues which have
                  converged.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.EigenvalueDecompose(System.Char,System.Char,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
      <summary>
        <para>
            Computes for an N-by-N real non-symmetric matrix A, the
            eigenvalues and, optionally, the left and/or right eigenvectors.</para>
      </summary>
      <param name="jobvl">
        <pre>
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of A are computed.
            </pre>
      </param>
      <param name="jobvr">
        <pre>
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A. N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="wr">
        <pre>
            Dimension (N)
            </pre>
      </param>
      <param name="wi">
        <pre>
            Dimension (N)
            WR and WI contain the real and imaginary parts,
            respectively, of the computed eigenvalues.  Complex
            conjugate pairs of eigenvalues appear consecutively
            with the eigenvalue having the positive imaginary part
            first.
            </pre>
      </param>
      <param name="vl">
        <pre>
            Dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            If the j-th eigenvalue is real, then u(j) = VL(:,j),
            the j-th column of VL.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
            u(j+1) = VL(:,j) - i*VL(:,j+1).
            </pre>
        <pre>
            The leading dimension of the array VL.  LDVL &gt;= 1; if
            JOBVL = 'V', LDVL &gt;= N.
            </pre>
      </param>
      <param name="vr">
        <pre>
            Dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = 'N', VR is not referenced.
            If the j-th eigenvalue is real, then v(j) = VR(:,j),
            the j-th column of VR.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
            v(j+1) = VR(:,j) - i*VR(:,j+1).
            </pre>
        <pre>
            The leading dimension of the array VR.  LDVR &gt;= 1; if
            JOBVR = 'V', LDVR &gt;= N.
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value.
            &gt; 0:  if <paramref name="info" /> = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors have been computed;
                  elements i+1:N of WR and WI contain eigenvalues which
                  have converged.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.GeneralizedEigenvalueDecompose(System.Char,System.Char,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
        <para>
            Computes for a pair of N-by-N complex nonsymmetric matrices
            (A,B), the generalized eigenvalues, and optionally, the left and/or
            right generalized eigenvectors.</para>
      </summary>
      <param name="jobvl">
        <code>
            JOBVL is CHARACTER*1
            = 'N':  do not compute the left generalized eigenvectors;
            = 'V':  compute the left generalized eigenvectors.
            </code>
      </param>
      <param name="jobvr">
        <code>
            JOBVR is CHARACTER*1
            = 'N':  do not compute the right generalized eigenvectors;
            = 'V':  compute the right generalized eigenvectors.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrices A, B, VL, and VR.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA, N)
            On entry, the matrix A in the pair (A,B).
            On exit, A has been overwritten.
            </code>
        <code>
            LDA is INTEGER
            The leading dimension of A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="b">
        <code>
            B is COMPLEX*16 array, dimension (LDB, N)
            On entry, the matrix B in the pair (A,B).
            On exit, B has been overwritten.
            </code>
        <code>
            LDB is INTEGER
            The leading dimension of B.  LDB &gt;= max(1,N).
            </code>
      </param>
      <param name="alpha">
        <code>
            ALPHA is COMPLEX*16 array, dimension (N)
            </code>
      </param>
      <param name="beta">
        <code>
            BETA is COMPLEX*16 array, dimension (N)
            On exit, ALPHA(j)/BETA(j), j=1,...,N, will be the
            generalized eigenvalues.
            Note: the quotients ALPHA(j)/BETA(j) may easily over- or
            underflow, and BETA(j) may even be zero.  Thus, the user
            should avoid naively computing the ratio alpha/beta.
            However, ALPHA will be always less than and usually
            comparable with norm(A) in magnitude, and BETA always less
            than and usually comparable with norm(B).
            </code>
      </param>
      <param name="vl">
        <code>
            VL is COMPLEX*16 array, dimension (LDVL,N)
            If JOBVL = 'V', the left generalized eigenvectors u(j) are
            stored one after another in the columns of VL, in the same
            order as their eigenvalues.
            Each eigenvector is scaled so the largest component has
            abs(real part) + abs(imag. part) = 1.
            Not referenced if JOBVL = 'N'.
            </code>
        <code>
            LDVL is INTEGER
            The leading dimension of the matrix VL. LDVL &gt;= 1, and
            if JOBVL = 'V', LDVL &gt;= N.
            </code>
      </param>
      <param name="vr">
        <code>
            VR is COMPLEX*16 array, dimension (LDVR,N)
            If JOBVR = 'V', the right generalized eigenvectors v(j) are
            stored one after another in the columns of VR, in the same
            order as their eigenvalues.
            Each eigenvector is scaled so the largest component has
            abs(real part) + abs(imag. part) = 1.
            Not referenced if JOBVR = 'N'.
            </code>
        <code>
            LDVR is INTEGER
            The leading dimension of the matrix VR. LDVR &gt;= 1, and
            if JOBVR = 'V', LDVR &gt;= N.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            =1,...,N:
                  The QZ iteration failed.  No eigenvectors have been
                  calculated, but ALPHA(j) and BETA(j) should be
                  correct for j=INFO+1,...,N.
            &gt; N:  =N+1: other then QZ iteration failed in DHGEQZ,
                  =N+2: error return from DTGEVC.
            </code>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.GeneralizedEigenvalueDecompose(System.Char,System.Char,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
      <summary>
        <para>
            Computes for a pair of N-by-N real nonsymmetric matrices (A,B)
            the generalized eigenvalues, and optionally, the left and/or right
            generalized eigenvectors.</para>
      </summary>
      <param name="jobvl">
        <code>
            JOBVL is CHARACTER*1
            = 'N':  do not compute the left generalized eigenvectors;
            = 'V':  compute the left generalized eigenvectors.
            </code>
      </param>
      <param name="jobvr">
        <code>
            JOBVR is CHARACTER*1
            = 'N':  do not compute the right generalized eigenvectors;
            = 'V':  compute the right generalized eigenvectors.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrices A, B, VL, and VR.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is DOUBLE PRECISION array, dimension (LDA, N)
            On entry, the matrix A in the pair (A,B).
            On exit, A has been overwritten.
            </code>
        <code>
            LDA is INTEGER
            The leading dimension of A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="b">
        <code>
            B is DOUBLE PRECISION array, dimension (LDB, N)
            On entry, the matrix B in the pair (A,B).
            On exit, B has been overwritten.
            </code>
        <code>
            LDB is INTEGER
            The leading dimension of B.  LDB &gt;= max(1,N).
            </code>
      </param>
      <param name="alphar">
        <code>
            ALPHAR is DOUBLE PRECISION array, dimension (N)
            </code>
      </param>
      <param name="alphai">
        <code>
            ALPHAI is DOUBLE PRECISION array, dimension (N)
            </code>
      </param>
      <param name="beta">
        <code>
            BETA is DOUBLE PRECISION array, dimension (N)
            On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
            be the generalized eigenvalues.  If ALPHAI(j) is zero, then
            the j-th eigenvalue is real; if positive, then the j-th and
            (j+1)-st eigenvalues are a complex conjugate pair, with
            ALPHAI(j+1) negative.
            Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
            may easily over- or underflow, and BETA(j) may even be zero.
            Thus, the user should avoid naively computing the ratio
            alpha/beta.  However, ALPHAR and ALPHAI will be always less
            than and usually comparable with norm(A) in magnitude, and
            BETA always less than and usually comparable with norm(B).
            </code>
      </param>
      <param name="vl">
        <code>
            VL is DOUBLE PRECISION array, dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order as
            their eigenvalues. If the j-th eigenvalue is real, then
            u(j) = VL(:,j), the j-th column of VL. If the j-th and
            (j+1)-th eigenvalues form a complex conjugate pair, then
            u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
            Each eigenvector is scaled so the largest component has
            abs(real part)+abs(imag. part)=1.
            Not referenced if JOBVL = 'N'.
            </code>
        <code>
            LDVL is INTEGER
            The leading dimension of the matrix VL. LDVL &gt;= 1, and
            if JOBVL = 'V', LDVL &gt;= N.
            </code>
      </param>
      <param name="vr">
        <code>
            VR is DOUBLE PRECISION array, dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order as
            their eigenvalues. If the j-th eigenvalue is real, then
            v(j) = VR(:,j), the j-th column of VR. If the j-th and
            (j+1)-th eigenvalues form a complex conjugate pair, then
            v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
            Each eigenvector is scaled so the largest component has
            abs(real part)+abs(imag. part)=1.
            Not referenced if JOBVR = 'N'.
            </code>
        <code>
            LDVR is INTEGER
            The leading dimension of the matrix VR. LDVR &gt;= 1, and
            if JOBVR = 'V', LDVR &gt;= N.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            = 1,...,N:
                  The QZ iteration failed.  No eigenvectors have been
                  calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
                  should be correct for j=INFO+1,...,N.
            &gt; N:  =N+1: other than QZ iteration failed in DHGEQZ.
                  =N+2: error return from DTGEVC.
            </code>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.GeneralizedSingularValueDecompose(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},System.Int32@)"></member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.GeneralizedSingularValueDecompose(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)"></member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.HermitianDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes the factorization of a complex Hermitian matrix A
            using the Bunch-Kaufman diagonal pivoting method.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, the block diagonal matrix D and the multipliers used
            to obtain the factor U or L (see below for further details).
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D.
            If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            &gt; 0:  if <paramref name="info" /> = i, D(i,i) is exactly zero.  The factorization
                  has been completed, but the block diagonal matrix D is
                  exactly singular, and division by zero will occur if it
                  is used to solve a system of equations.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.HermitianEigenvalueDecompose(System.Char,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},System.Int32@)">
      <summary>
        <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            complex Hermitian matrix A.</para>
      </summary>
      <param name="jobz">
        <pre>
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </pre>
      </param>
      <param name="uplo">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array, dimension (LDA, N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if <paramref name="info" /> = 0, A contains the
            orthonormal eigenvectors of the matrix A.
            If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
            or the upper triangle (if UPLO='U') of A, including the
            diagonal, is destroyed.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="w">
        <pre>
            Dimension (N)
            If <paramref name="info" /> = 0, the eigenvalues in ascending order.
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            &gt; 0:  if <paramref name="info" /> = i and JOBZ = 'N', then the algorithm failed
                  to converge; i off-diagonal elements of an intermediate
                  tridiagonal form did not converge to zero;
                  if <paramref name="info" /> = i and JOBZ = 'V', then the algorithm failed
                  to compute an eigenvalue while working on the sub-matrix
                  lying in rows and columns <paramref name="info" />/(N+1) through
                  mod(<paramref name="info" />,N+1).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.HermitianEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},`0,`0@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number of a complex
            Hermitian matrix A using the factorization A = U*D*U<sup>H</sup> or
            A = L*D*L<sup>H</sup> computed by ZHETRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>H</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>H</sup>.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by ZHETRF.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by ZHETRF.
            </pre>
      </param>
      <param name="anorm">
        <pre>
            The 1-norm of the original matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.HermitianGeneralizedEigenvalueDecompose(System.Int32,System.Char,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},System.Int32@)">
      <summary>
        <para>
            Computes all the eigenvalues, and optionally, the eigenvectors
            of a complex generalized Hermitian-definite eigenproblem, of the form
            A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.</para>
      </summary>
      <param name="itype">
        <code>
            ITYPE is INTEGER
            Specifies the problem type to be solved:
            = 1:  A*x = (lambda)*B*x
            = 2:  A*B*x = (lambda)*x
            = 3:  B*A*x = (lambda)*x
            </code>
      </param>
      <param name="jobz">
        <code>
            JOBZ is CHARACTER*1
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </code>
      </param>
      <param name="uplo">
        <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangles of A and B are stored;
            = 'L':  Lower triangles of A and B are stored.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrices A and B.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA, N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            matrix Z of eigenvectors.  The eigenvectors are normalized
            as follows:
            if ITYPE = 1 or 2, Z**H*B*Z = I;
            if ITYPE = 3, Z**H*inv(B)*Z = I.
            If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
            or the lower triangle (if UPLO='L') of A, including the
            diagonal, is destroyed.
            </code>
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="b">
        <code>
            B is COMPLEX*16 array, dimension (LDB, N)
            On entry, the Hermitian matrix B.  If UPLO = 'U', the
            leading N-by-N upper triangular part of B contains the
            upper triangular part of the matrix B.  If UPLO = 'L',
            the leading N-by-N lower triangular part of B contains
            the lower triangular part of the matrix B.
            On exit, if INFO &lt;= N, the part of B containing the matrix is
            overwritten by the triangular factor U or L from the Cholesky
            factorization B = U**H*U or B = L*L**H.
            </code>
        <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </code>
      </param>
      <param name="w">
        <code>
            W is DOUBLE PRECISION array, dimension (N)
            If INFO = 0, the eigenvalues in ascending order.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  ZPOTRF or ZHEEVD returned an error code:
               &lt;= N:  if INFO = i and JOBZ = 'N', then the algorithm
                      failed to converge; i off-diagonal elements of an
                      intermediate tridiagonal form did not converge to
                      zero;
                      if INFO = i and JOBZ = 'V', then the algorithm
                      failed to compute an eigenvalue while working on
                      the submatrix lying in rows and columns INFO/(N+1)
                      through mod(INFO,N+1);
               &gt; N:   if INFO = N + i, for 1 &lt;= i &lt;= N, then the leading
                      minor of order i of B is not positive definite.
                      The factorization of B could not be completed and
                      no eigenvalues or eigenvectors were computed.
            </code>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.HermitianInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes the inverse of a complex Hermitian indefinite matrix
            A using the factorization A = U*D*U<sup>H</sup> or A = L*D*L<sup>H</sup> computed by
            ZHETRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>H</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>H</sup>.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array, dimension (LDA,N)
            On entry, the block diagonal matrix D and the multipliers
            used to obtain the factor U or L as computed by ZHETRF.
            On exit, if <paramref name="info" /> = 0, the (Hermitian) inverse of the original
            matrix.  If UPLO = 'U', the upper triangular part of the
            inverse is formed and the part of A below the diagonal is not
            referenced; if UPLO = 'L' the lower triangular part of the
            inverse is formed and the part of A above the diagonal is
            not referenced.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by ZHETRF.
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0: successful exit
            &lt; 0: if <paramref name="info" /> = -i, the i-th argument had an illegal value
            &gt; 0: if <paramref name="info" /> = i, D(i,i) = 0; the matrix is singular and its
                 inverse could not be computed.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.HermitianSolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations A*X = B with a complex
            Hermitian matrix A using the factorization A = U*D*U<sup>H</sup> or
            A = L*D*L<sup>H</sup> computed by ZHETRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>H</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>H</sup>.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is complex array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by ZHETRF.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by ZHETRF.
            </pre>
      </param>
      <param name="b">
        <pre>
            B is complex array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LQDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
        <para>
            Computes an LQ factorization of a complex M-by-N matrix A:
            A = L * Q.</para>
      </summary>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix A.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and below the diagonal of the array
            contain the m-by-min(m,n) lower trapezoidal matrix L (L is
            lower triangular if m &lt;= n); the elements above the diagonal,
            with the array TAU, represent the unitary matrix Q as a
            product of elementary reflectors (see Further Details).
            </code>
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LQDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
      <summary>
        <para>
            Computes an LQ factorization of a complex M-by-N matrix A:
            A = L * Q.</para>
      </summary>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix A.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and below the diagonal of the array
            contain the m-by-min(m,n) lower trapezoidal matrix L (L is
            lower triangular if m &lt;= n); the elements above the diagonal,
            with the array TAU, represent the unitary matrix Q as a
            product of elementary reflectors (see Further Details).
            </code>
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LQOrthogonalMultiply(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
      <summary>
        <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
      </summary>
      <param name="side">
        <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
            </code>
      </param>
      <param name="trans">
        <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix C. M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix C. N &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is DOUBLE PRECISION array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGELQF in the first k rows of its array argument A.
            </code>
        <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,K).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGELQF.
            </code>
      </param>
      <param name="c">
        <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
        <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LQUnitaryMultiply(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
        <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(k)**H .</para>
      </summary>
      <param name="side">
        <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
            </code>
      </param>
      <param name="trans">
        <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Conjugate transpose, apply Q**H.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix C. M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix C. N &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGELQF in the first k rows of its array argument A.
            </code>
        <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,K).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGELQF.
            </code>
      </param>
      <param name="c">
        <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
        <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
      <summary>
             ZGETRF computes an LU decomposition of a general M-by-N matrix A
             using partial pivoting with row interchanges.
             <para>
             The decomposition has the form</para><para><center>A = P * L * U</center></para><para>where P is a permutation matrix, L is lower triangular with unit
             diagonal elements (lower trapezoidal if m &gt; n), and U is upper
             triangular (upper trapezoidal if m &lt; n).
             </para><para>
             This is the right-looking Level 3 BLAS version of the algorithm.
             </para></summary>
      <param name="m">An integer specifying the number of rows
             of the matrix <paramref name="a" />. Must be greater than
             or equal to zero.</param>
      <param name="n">An integer specifying the number of
             columns of the matrix <paramref name="a" />. Must be
             greater than or equal to zero.
             </param>
      <param name="a">complex T-precision array specifying the
             <paramref name="m" />-by-<paramref name="n" /> matrix
             to be factored. On exit, the factors L and U from the
             decomposition A = P*L*U; the unit diagonal elements of
             L are not stored.</param>
      <param name="ipiv">Integer array of length
             min(<paramref name="m" />,<paramref name="n" />) that
             will hold the pivot indexes. Row <i>i</i> of the
             matrix was interchanged with row
             <paramref name="ipiv" />[<i>i</i>].</param>
      <param name="info">Reference to an integer containing a
             result code. Zero indicates success. Greater than zero
             indicates U(i,i) is exactly zero. The decomposition
             has been completed, but the factor U is exactly
             singular, and division by zero will occur if it is used
             to solve a system of equations.</param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes an LU factorization of a general M-by-N matrix A
            using partial pivoting with row interchanges.</para>
      </summary>
      <param name="m">
        <pre>
            The number of rows of the matrix A.  M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            On entry, the M-by-N matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (min(M,N))
            The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            &gt; 0:  if <paramref name="info" /> = i, U(i,i) is exactly zero. The factorization
                  has been completed, but the factor U is exactly
                  singular, and division by zero will occur if it is used
                  to solve a system of equations.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0,`0@,System.Int32@)">
      <summary>
             ZGECON estimates the reciprocal of the condition number of a general
             real matrix A, inthis. either the 1-norm or the infinity-norm, using
             the LU decomposition computed by ZGETRF.
            
             An estimate is obtained for norm(inv(A)), and the reciprocal of the
             condition number is computed as
                RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            
             Arguments
             =========
            
             NORM    (input) CHARACTER*1
             Specifies whether the 1-norm condition number or the
             infinity-norm condition number is required:
                = '1' or 'O':  1-norm;
                = 'I':         Infinity-norm.
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N &gt;= 0.
            
             A       (input) ZOUBLE PRECISION array, dimension (LDA,N)
             The factors L and U from the decomposition A = P*L*U
             as computed by ZGETRF.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= Max(1,N).
            
             ANORM   (input) ZOUBLE PRECISION
             If NORM = '1' or 'O', the 1-norm of the original matrix A.
             If NORM = 'I', the infinity-norm of the original matrix A.
            
             RCOND   (output) ZOUBLE PRECISION
             The reciprocal of the condition number of the matrix A,
             computed as RCOND = 1/(norm(A) * norm(inv(A))).
            
             WORK    (workspace) ZOUBLE PRECISION array, dimension (4*N)
            
             IWORK   (workspace) INTEGER array, dimension (N)
            
             <paramref name="info" />    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            
            
            </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,Extreme.Collections.Array2D{`0},`0,`0@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number of a general
            real matrix A, in either the 1-norm or the infinity-norm, using
            the LU factorization computed by DGETRF.</para>
      </summary>
      <param name="norm">
        <pre>
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by DGETRF.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="anorm">
        <pre>
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUInvert(System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
      <summary>
             ZGETRI computes the inverse of a matrix using the LU decomposition
             computed by ZGETRF.
            
             This method inverts U and then computes inv(A) by solving the system
             inv(A)*L = inv(U) for inv(A).
            
             Arguments
             =========
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N &gt;= 0.
            
             A       (input/output) ZOUBLE PRECISION array, dimension (LDA,N)
             On entry, the factors L and U from the decomposition
             A = P*L*U as computed by ZGETRF.
             On exit, if <paramref name="info" /> = 0, the inverse of the original matrix A.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= Max(1,N).
            
             IPIV    (input) INTEGER array, dimension (N)
             The pivot indexes from ZGETRF; for 1&lt; =i&lt; =N, row i of the
             matrix was interchanged with row IPIVi.
            
             WORK    (workspace/output) ZOUBLE PRECISION array, dimension (LWORK)
             On exit, if <paramref name="info" /> =0, then WORK(1) returns the optimal LWORK.
            
             LWORK   (input) INTEGER
             The dimension of the array WORK.  LWORK &gt;= Max(1,N).
             For optimal performance LWORK &gt;= N*NB, where NB is
             the optimal blocksize returned by ILAENV.
            
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            
             <paramref name="info" />    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
             &gt; 0:  if <paramref name="info" /> = i, U(i,i) is exactly zero; the matrix is
             singular and its inverse could not be computed.
            </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUInvert(System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes the inverse of a matrix using the LU factorization
            computed by DGETRF.</para>
      </summary>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            On entry, the factors L and U from the factorization
            A = P*L*U as computed by DGETRF.
            On exit, if <paramref name="info" /> = 0, the inverse of the original matrix A.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            The pivot indices from DGETRF; for 1&lt;=i&lt;=N, row i of the
            matrix was interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            &gt; 0:  if <paramref name="info" /> = i, U(i,i) is exactly zero; the matrix is
                  singular and its inverse could not be computed.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
             ZGETRS solves a system of linear equations
                A * X = B  or  A' * X = B
             with a general N-by-N matrix A using the LU decomposition computed
             by ZGETRF.
            
             Arguments
             =========
            
             TRANS   (input) CHARACTER*1
             Specifies the form of the system of equations:
                = 'N':  A * X = B  (No transpose)
                = TransposeOperation.Transpose:  A'* X = B  (Transpose)
                = 'C':  A'* X = B  (Conjugate transpose = Transpose)
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N &gt;= 0.
            
             NRHS    (input) INTEGER
             The number of right hand sides, i.e., the number of columns
             of the matrix B.  NRHS &gt;= 0.
            
             A       (input) ZOUBLE PRECISION array, dimension (LDA,N)
             The factors L and U from the decomposition A = P*L*U
             as computed by ZGETRF.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= Max(1,N).
            
             IPIV    (input) INTEGER array, dimension (N)
             The pivot indexes from ZGETRF; for 1&lt; =i&lt; =N, row i of the
             matrix was interchanged with row IPIVi.
            
             B       (input/output) ZOUBLE PRECISION array, dimension (LDB,NRHS)
             On entry, the right hand side matrix B.
             On exit, the solution matrix X.
            
             LDB     (input) INTEGER
             The leading dimension of the array B.  LDB &gt;= Max(1,N).
            
             <paramref name="info" />    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            
             =====================================================================
            
            </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{`0},System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations
               A * X = B  or  A<sup>T</sup> * X = B
            with a general N-by-N matrix A using the LU factorization computed
            by DGETRF.</para>
      </summary>
      <param name="trans">
        <pre>
            Specifies the form of the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A<sup>T</sup>* X = B  (Transpose)
            = 'C':  A<sup>T</sup>* X = B  (Conjugate transpose = Transpose)
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by DGETRF.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            The pivot indices from DGETRF; for 1&lt;=i&lt;=N, row i of the
            matrix was interchanged with row IPIV(i).
            </pre>
      </param>
      <param name="b">
        <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.Name">
      <summary>
            Gets the name of the implementation.
            </summary>
    </member>
    <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.Platform">
      <summary>
            Gets the processor architecture supported by the implementation.
            </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QLDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
        <para>
            Computes a QL factorization of a complex M-by-N matrix A:
            A = Q * L.</para>
      </summary>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix A.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if m &gt;= n, the lower triangle of the subarray
            A(m-n+1:m,1:n) contains the N-by-N lower triangular matrix L;
            if m &lt;= n, the elements on and below the (n-m)-th
            superdiagonal contain the M-by-N lower trapezoidal matrix L;
            the remaining elements, with the array TAU, represent the
            unitary matrix Q as a product of elementary reflectors
            (see Further Details).
            </code>
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QLDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
      <summary>
        <para>
            Computes a QL factorization of a complex M-by-N matrix A:
            A = Q * L.</para>
      </summary>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix A.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if m &gt;= n, the lower triangle of the subarray
            A(m-n+1:m,1:n) contains the N-by-N lower triangular matrix L;
            if m &lt;= n, the elements on and below the (n-m)-th
            superdiagonal contain the M-by-N lower trapezoidal matrix L;
            the remaining elements, with the array TAU, represent the
            unitary matrix Q as a product of elementary reflectors
            (see Further Details).
            </code>
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QLOrthogonalMultiply(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
      <summary>
        <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
      </summary>
      <param name="side">
        <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
            </code>
      </param>
      <param name="trans">
        <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix C. M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix C. N &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is DOUBLE PRECISION array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGEQLF in the last k columns of its array argument A.
            </code>
        <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA &gt;= max(1,M);
            if SIDE = 'R', LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQLF.
            </code>
      </param>
      <param name="c">
        <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
        <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QLUnitaryMultiply(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
        <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
      </summary>
      <param name="side">
        <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
            </code>
      </param>
      <param name="trans">
        <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Transpose, apply Q**H.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix C. M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix C. N &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGEQLF in the last k columns of its array argument A.
            </code>
        <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA &gt;= max(1,M);
            if SIDE = 'R', LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGEQLF.
            </code>
      </param>
      <param name="c">
        <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
        <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QRDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
             ZGEQRF computes a QR decomposition of a real M-by-N matrix A:
             A = Q * R.
            
             Arguments
             =========
            
             M       (input) INTEGER
             The number of rows of the matrix A.  M &gt;= 0.
            
             N       (input) INTEGER
             The number of columns of the matrix A.  N &gt;= 0.
            
             A       (input/output) ZOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit, the elements on and above the diagonal of the array
             contain the min(M,N)-by-N upper trapezoidal matrix R (R is
             upper triangular if m &gt;= n); the elements below the diagonal,
             with the array TAU, represent the orthogonal matrix Q as a
             product of min(m,n) elementary reflectors (see Further
             Zetails).
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA &gt;= max(1,M).
            
             TAU     (output) ZOUBLE PRECISION array, dimension (min(M,N))
             The scalar factors of the elementary reflectors (see Further
             Zetails).
            
             WORK    (workspace/output) ZOUBLE PRECISION array, dimension (LWORK)
             On exit, if <paramref name="info" /> = 0, WORK(1) returns the optimal LWORK.
            
             LWORK   (input) INTEGER
             The dimension of the array WORK.  LWORK &gt;= max(1,N).
             For optimum performance LWORK &gt;= N*NB, where NB is
             the optimal blocksize.
            
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            
             <paramref name="info" />    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            
             Further Zetails
             ===============
            
             The matrix Q is represented as a product of elementary reflectors
            
                Q = H(1) H(2) . . . H(k), where k = min(m,n).
            
             Each H(i) has the form
            
                H(i) = I - tau * v * v'
            
             where tau is a real scalar, and v is a real vector with
             v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit inthis. A(i+1:m,i),
             and tau inthis. TAU(i).
            </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QRDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{`0},System.Int32@)">
      <summary>
        <para>
            Computes a QR factorization with column pivoting of a
            matrix A:  A*P = Q*R  using Level 3 BLAS.</para>
      </summary>
      <param name="m">
        <pre>
            The number of rows of the matrix A. M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of the array contains the
            min(M,N)-by-N upper trapezoidal matrix R; the elements below
            the diagonal, together with the array TAU, represent the
            orthogonal matrix Q as a product of min(M,N) elementary
            reflectors.
            </pre>
        <pre>
            The leading dimension of the array A. LDA &gt;= max(1,M).
            </pre>
      </param>
      <param name="jpvt">
        <pre>
            Dimension (N)
            On entry, if JPVT(J).ne.0, the J-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(J)=0,
            the J-th column of A is a free column.
            On exit, if JPVT(J)=K, then the J-th column of A*P was the
            the K-th column of A.
            </pre>
      </param>
      <param name="tau">
        <pre>
            Dimension (min(M,N))
            The scalar factors of the elementary reflectors.
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0: successful exit.
            &lt; 0: if <paramref name="info" /> = -i, the i-th argument had an illegal value.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QRDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
      <summary>
        <para>
            Computes a QR factorization of a real M-by-N matrix A:
            A = Q * R.</para>
      </summary>
      <param name="m">
        <pre>
            The number of rows of the matrix A.  M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and above the diagonal of the array
            contain the min(M,N)-by-N upper trapezoidal matrix R (R is
            upper triangular if m &gt;= n); the elements below the diagonal,
            with the array TAU, represent the orthogonal matrix Q as a
            product of min(m,n) elementary reflectors (see Further
            Details).
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </pre>
      </param>
      <param name="tau">
        <pre>
            Dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QROrthogonalMultiply(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
      <summary>
        <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q<sup>T</sup> * C       C * Q<sup>T</sup>
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
      </summary>
      <param name="side">
        <pre>
            = 'L': apply Q or Q<sup>T</sup> from the Left;
            = 'R': apply Q or Q<sup>T</sup> from the Right.
            </pre>
      </param>
      <param name="trans">
        <pre>
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q<sup>T</sup>.
            </pre>
      </param>
      <param name="m">
        <pre>
            The number of rows of the matrix C. M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix C. N &gt;= 0.
            </pre>
      </param>
      <param name="k">
        <pre>
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGEQRF in the first k columns of its array argument A.
            A is modified by the routine but restored on exit.
            </pre>
        <pre>
            The leading dimension of the array A.
            If SIDE = 'L', LDA &gt;= max(1,M);
            if SIDE = 'R', LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="tau">
        <pre>
            Dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQRF.
            </pre>
      </param>
      <param name="c">
        <pre>
            Dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q<sup>T</sup>*C or C*Q<sup>T</sup> or C*Q.
            </pre>
        <pre>
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QRUnitaryMultiply(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
        <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q<sup>H</sup> * C       C * Q<sup>H</sup>
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
      </summary>
      <param name="side">
        <pre>
            = 'L': apply Q or Q<sup>H</sup> from the Left;
            = 'R': apply Q or Q<sup>H</sup> from the Right.
            </pre>
      </param>
      <param name="trans">
        <pre>
            = 'N':  No transpose, apply Q;
            = 'C':  Conjugate transpose, apply Q<sup>H</sup>.
            </pre>
      </param>
      <param name="m">
        <pre>
            The number of rows of the matrix C. M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix C. N &gt;= 0.
            </pre>
      </param>
      <param name="k">
        <pre>
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGEQRF in the first k columns of its array argument A.
            </pre>
        <pre>
            The leading dimension of the array A.
            If SIDE = 'L', LDA &gt;= max(1,M);
            if SIDE = 'R', LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="tau">
        <pre>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGEQRF.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q<sup>H</sup>*C or C*Q<sup>H</sup> or C*Q.
            </pre>
        <pre>
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.RQDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
        <para>
            Computes an RQ factorization of a complex M-by-N matrix A:
            A = R * Q.</para>
      </summary>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix A.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if m &lt;= n, the upper triangle of the subarray
            A(1:m,n-m+1:n) contains the M-by-M upper triangular matrix R;
            if m &gt;= n, the elements on and above the (m-n)-th subdiagonal
            contain the M-by-N upper trapezoidal matrix R;
            the remaining elements, with the array TAU, represent the
            unitary matrix Q as a product of min(m,n) elementary
            reflectors (see Further Details).
            </code>
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.RQDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
      <summary>
        <para>
            Computes an RQ factorization of a complex M-by-N matrix A:
            A = R * Q.</para>
      </summary>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix A.  M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix A.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if m &lt;= n, the upper triangle of the subarray
            A(1:m,n-m+1:n) contains the M-by-M upper triangular matrix R;
            if m &gt;= n, the elements on and above the (m-n)-th subdiagonal
            contain the M-by-N upper trapezoidal matrix R;
            the remaining elements, with the array TAU, represent the
            unitary matrix Q as a product of min(m,n) elementary
            reflectors (see Further Details).
            </code>
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.RQOrthogonalMultiply(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
      <summary>
        <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
      </summary>
      <param name="side">
        <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
            </code>
      </param>
      <param name="trans">
        <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix C. M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix C. N &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is DOUBLE PRECISION array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGERQF in the last k rows of its array argument A.
            </code>
        <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,K).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGERQF.
            </code>
      </param>
      <param name="c">
        <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
        <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.RQUnitaryMultiply(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
        <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(1)**H H(2)**H .</para>
      </summary>
      <param name="side">
        <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
            </code>
      </param>
      <param name="trans">
        <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Transpose, apply Q**H.
            </code>
      </param>
      <param name="m">
        <code>
            M is INTEGER
            The number of rows of the matrix C. M &gt;= 0.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The number of columns of the matrix C. N &gt;= 0.
            </code>
      </param>
      <param name="k">
        <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M &gt;= K &gt;= 0;
            if SIDE = 'R', N &gt;= K &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is COMPLEX*16 array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGERQF in the last k rows of its array argument A.
            </code>
        <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA &gt;= max(1,K).
            </code>
      </param>
      <param name="tau">
        <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGERQF.
            </code>
      </param>
      <param name="c">
        <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
        <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC &gt;= max(1,M).
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SingularValueDecompose(System.Char,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
        <para>
            Computes the singular value decomposition (SVD) of a complex
            M-by-N matrix A, optionally computing the left and/or right singular
            vectors, by using divide-and-conquer method.</para>
      </summary>
      <param name="jobz">
        <pre>
            Specifies options for computing all or part of the matrix U:
            = 'A':  all M columns of U and all N rows of V<sup>H</sup> are
                    returned in the arrays U and VT;
            = 'S':  the first min(M,N) columns of U and the first
                    min(M,N) rows of V<sup>H</sup> are returned in the arrays U
                    and VT;
            = 'O':  If M &gt;= N, the first N columns of U are overwritten
                    in the array A and all rows of V<sup>H</sup> are returned in
                    the array VT;
                    otherwise, all columns of U are returned in the
                    array U and the first M rows of V<sup>H</sup> are overwritten
                    in the array A;
            = 'N':  no columns of U or rows of V<sup>H</sup> are computed.
            </pre>
      </param>
      <param name="m">
        <pre>
            The number of rows of the input matrix A.  M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the input matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if JOBZ = 'O',  A is overwritten with the first N columns
                            of U (the left singular vectors, stored
                            columnwise) if M &gt;= N;
                            A is overwritten with the first M rows
                            of V<sup>H</sup> (the right singular vectors, stored
                            rowwise) otherwise.
            if JOBZ .ne. 'O', the contents of A are destroyed.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </pre>
      </param>
      <param name="s">
        <pre>
            Dimension (min(M,N))
            The singular values of A, sorted so that S(i) &gt;= S(i+1).
            </pre>
      </param>
      <param name="u">
        <pre>
            U is COMPLEX*16 array, dimension (LDU,UCOL)
            UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
            UCOL = min(M,N) if JOBZ = 'S'.
            If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
            unitary matrix U;
            if JOBZ = 'S', U contains the first min(M,N) columns of U
            (the left singular vectors, stored columnwise);
            if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.
            </pre>
        <pre>
            The leading dimension of the array U.  LDU &gt;= 1; if
            JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M.
            </pre>
      </param>
      <param name="vt">
        <pre>
            VT is COMPLEX*16 array, dimension (LDVT,N)
            If JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, VT contains the
            N-by-N unitary matrix V<sup>H</sup>;
            if JOBZ = 'S', VT contains the first min(M,N) rows of
            V<sup>H</sup> (the right singular vectors, stored rowwise);
            if JOBZ = 'O' and M &lt; N, or JOBZ = 'N', VT is not referenced.
            </pre>
        <pre>
            The leading dimension of the array VT.  LDVT &gt;= 1; if
            JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, LDVT &gt;= N;
            if JOBZ = 'S', LDVT &gt;= min(M,N).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit.
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value.
            &gt; 0:  The updating process of DBDSDC did not converge.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SingularValueDecompose(System.Char,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
      <summary>
        <para>
            Computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.</para>
      </summary>
      <param name="jobz">
        <pre>
            Specifies options for computing all or part of the matrix U:
            = 'A':  all M columns of U and all N rows of V<sup>T</sup> are
                    returned in the arrays U and VT;
            = 'S':  the first min(M,N) columns of U and the first
                    min(M,N) rows of V<sup>T</sup> are returned in the arrays U
                    and VT;
            = 'O':  If M &gt;= N, the first N columns of U are overwritten
                    on the array A and all rows of V<sup>T</sup> are returned in
                    the array VT;
                    otherwise, all columns of U are returned in the
                    array U and the first M rows of V<sup>T</sup> are overwritten
                    in the array A;
            = 'N':  no columns of U or rows of V<sup>T</sup> are computed.
            </pre>
      </param>
      <param name="m">
        <pre>
            The number of rows of the input matrix A.  M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the input matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if JOBZ = 'O',  A is overwritten with the first N columns
                            of U (the left singular vectors, stored
                            columnwise) if M &gt;= N;
                            A is overwritten with the first M rows
                            of V<sup>T</sup> (the right singular vectors, stored
                            rowwise) otherwise.
            if JOBZ .ne. 'O', the contents of A are destroyed.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </pre>
      </param>
      <param name="s">
        <pre>
            Dimension (min(M,N))
            The singular values of A, sorted so that S(i) &gt;= S(i+1).
            </pre>
      </param>
      <param name="u">
        <pre>
            Dimension (LDU,UCOL)
            UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
            UCOL = min(M,N) if JOBZ = 'S'.
            If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
            orthogonal matrix U;
            if JOBZ = 'S', U contains the first min(M,N) columns of U
            (the left singular vectors, stored columnwise);
            if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.
            </pre>
        <pre>
            The leading dimension of the array U.  LDU &gt;= 1; if
            JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M.
            </pre>
      </param>
      <param name="vt">
        <pre>
            Dimension (LDVT,N)
            If JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, VT contains the
            N-by-N orthogonal matrix V<sup>T</sup>;
            if JOBZ = 'S', VT contains the first min(M,N) rows of
            V<sup>T</sup> (the right singular vectors, stored rowwise);
            if JOBZ = 'O' and M &lt; N, or JOBZ = 'N', VT is not referenced.
            </pre>
        <pre>
            The leading dimension of the array VT.  LDVT &gt;= 1; if
            JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, LDVT &gt;= N;
            if JOBZ = 'S', LDVT &gt;= min(M,N).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit.
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value.
            &gt; 0:  DBDSDC did not converge, updating process failed.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SymmetricDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes the factorization of a real symmetric matrix A using
            the Bunch-Kaufman diagonal pivoting method.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, the block diagonal matrix D and the multipliers used
            to obtain the factor U or L (see below for further details).
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D.
            If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            &gt; 0:  if <paramref name="info" /> = i, D(i,i) is exactly zero.  The factorization
                  has been completed, but the block diagonal matrix D is
                  exactly singular, and division by zero will occur if it
                  is used to solve a system of equations.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SymmetricEigenvalueDecompose(System.Char,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
      <summary>
        <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            real symmetric matrix A.</para>
      </summary>
      <param name="jobz">
        <pre>
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </pre>
      </param>
      <param name="storedTriangle">
        <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA, N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if <paramref name="info" /> = 0, A contains the
            orthonormal eigenvectors of the matrix A.
            If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
            or the upper triangle (if UPLO='U') of A, including the
            diagonal, is destroyed.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="w">
        <pre>
            Dimension (N)
            If <paramref name="info" /> = 0, the eigenvalues in ascending order.
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            &gt; 0:  if <paramref name="info" /> = i and JOBZ = 'N', then the algorithm failed
                  to converge; i off-diagonal elements of an intermediate
                  tridiagonal form did not converge to zero;
                  if <paramref name="info" /> = i and JOBZ = 'V', then the algorithm failed
                  to compute an eigenvalue while working on the sub-matrix
                  lying in rows and columns <paramref name="info" />/(N+1) through
                  mod(<paramref name="info" />,N+1).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SymmetricEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},`0,`0@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a real symmetric matrix A using the factorization
            A = U*D*U<sup>T</sup> or A = L*D*L<sup>T</sup> computed by DSYTRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>T</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>T</sup>.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by DSYTRF.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by DSYTRF.
            </pre>
      </param>
      <param name="anorm">
        <pre>
            The 1-norm of the original matrix A.
            </pre>
      </param>
      <param name="rcond">
        <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SymmetricGeneralizedEigenvalueDecompose(System.Int32,System.Char,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
      <summary>
        <para>
            Computes all the eigenvalues, and optionally, the eigenvectors
            of a real generalized symmetric-definite eigenproblem, of the form
            A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.</para>
      </summary>
      <param name="itype">
        <code>
            ITYPE is INTEGER
            Specifies the problem type to be solved:
            = 1:  A*x = (lambda)*B*x
            = 2:  A*B*x = (lambda)*x
            = 3:  B*A*x = (lambda)*x
            </code>
      </param>
      <param name="jobz">
        <code>
            JOBZ is CHARACTER*1
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </code>
      </param>
      <param name="uplo">
        <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangles of A and B are stored;
            = 'L':  Lower triangles of A and B are stored.
            </code>
      </param>
      <param name="n">
        <code>
            N is INTEGER
            The order of the matrices A and B.  N &gt;= 0.
            </code>
      </param>
      <param name="a">
        <code>
            A is DOUBLE PRECISION array, dimension (LDA, N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            matrix Z of eigenvectors.  The eigenvectors are normalized
            as follows:
            if ITYPE = 1 or 2, Z**T*B*Z = I;
            if ITYPE = 3, Z**T*inv(B)*Z = I.
            If JOBZ = 'N', then on exit the upper triangle (if UPLO='U')
            or the lower triangle (if UPLO='L') of A, including the
            diagonal, is destroyed.
            </code>
        <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </code>
      </param>
      <param name="b">
        <code>
            B is DOUBLE PRECISION array, dimension (LDB, N)
            On entry, the symmetric matrix B.  If UPLO = 'U', the
            leading N-by-N upper triangular part of B contains the
            upper triangular part of the matrix B.  If UPLO = 'L',
            the leading N-by-N lower triangular part of B contains
            the lower triangular part of the matrix B.
            On exit, if INFO &lt;= N, the part of B containing the matrix is
            overwritten by the triangular factor U or L from the Cholesky
            factorization B = U**T*U or B = L*L**T.
            </code>
        <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </code>
      </param>
      <param name="w">
        <code>
            W is DOUBLE PRECISION array, dimension (N)
            If INFO = 0, the eigenvalues in ascending order.
            </code>
      </param>
      <param name="info">
        <code>
            INFO is INTEGER
            = 0:  successful exit
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value
            &gt; 0:  DPOTRF or DSYEVD returned an error code:
               &lt;= N:  if INFO = i and JOBZ = 'N', then the algorithm
                      failed to converge; i off-diagonal elements of an
                      intermediate tridiagonal form did not converge to
                      zero;
                      if INFO = i and JOBZ = 'V', then the algorithm
                      failed to compute an eigenvalue while working on
                      the submatrix lying in rows and columns INFO/(N+1)
                      through mod(INFO,N+1);
               &gt; N:   if INFO = N + i, for 1 &lt;= i &lt;= N, then the leading
                      minor of order i of B is not positive definite.
                      The factorization of B could not be completed and
                      no eigenvalues or eigenvectors were computed.
            </code>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SymmetricInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
      <summary>
        <para>
            Computes the inverse of a real symmetric indefinite matrix
            A using the factorization A = U*D*U<sup>T</sup> or A = L*D*L<sup>T</sup> computed by
            DSYTRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>T</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>T</sup>.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            On entry, the block diagonal matrix D and the multipliers
            used to obtain the factor U or L as computed by DSYTRF.
            On exit, if <paramref name="info" /> = 0, the (symmetric) inverse of the original
            matrix.  If UPLO = 'U', the upper triangular part of the
            inverse is formed and the part of A below the diagonal is not
            referenced; if UPLO = 'L' the lower triangular part of the
            inverse is formed and the part of A above the diagonal is
            not referenced.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by DSYTRF.
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0: successful exit
            &lt; 0: if <paramref name="info" /> = -i, the i-th argument had an illegal value
            &gt; 0: if <paramref name="info" /> = i, D(i,i) = 0; the matrix is singular and its
                 inverse could not be computed.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SymmetricSolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{`0},System.Int32@)">
      <summary>
        <para>
            Solves a system of linear equations A*X = B with a real
            symmetric matrix A using the factorization A = U*D*U<sup>T</sup> or
            A = L*D*L<sup>T</sup> computed by DSYTRF.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>T</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>T</sup>.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by DSYTRF.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="ipiv">
        <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by DSYTRF.
            </pre>
      </param>
      <param name="b">
        <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.TriangularEstimateCondition(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0@,System.Int32@)">
      <summary>
            Approximates the reciprocal of the condition number of a complex triangular matrix.
            </summary>
      <param name="norm">A <see cref="T:Extreme.Mathematics.MatrixNorm" /> value that specifies which norm to use in the expression for the condition number.</param>
      <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle" /> value that indicates whether the matrix is upper
            or lower triangular.</param>
      <param name="diag">A <see cref="T:Extreme.Mathematics.MatrixDiagonal" /> value that indicates whether the matrix is unit diagonal.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="rcond">On return, an estimate for the reciprocal of the condition number of the matrix.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.TriangularEstimateCondition(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{`0},`0@,System.Int32@)">
      <summary>
        <para>
            Estimates the reciprocal of the condition number of a
            triangular matrix A, in either the 1-norm or the infinity-norm.</para>
      </summary>
      <param name="norm">
        <pre>
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </pre>
      </param>
      <param name="storedTriangle">
        <pre>
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </pre>
      </param>
      <param name="diag">
        <pre>
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            The triangular matrix A.  If UPLO = 'U', the leading N-by-N
            upper triangular part of the array A contains the upper
            triangular matrix, and the strictly lower triangular part of
            A is not referenced.  If UPLO = 'L', the leading N-by-N lower
            triangular part of the array A contains the lower triangular
            matrix, and the strictly upper triangular part of A is not
            referenced.  If DIAG = 'U', the diagonal elements of A are
            also not referenced and are assumed to be 1.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="rcond">
        <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info" /> = -i, the i-th argument had an illegal value
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.TriangularInvert(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
            Computes the inverse of a complex triangular matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle" /> value that indicates whether the matrix is upper
            or lower triangular.</param>
      <param name="diag">A <see cref="T:Extreme.Mathematics.MatrixDiagonal" /> value that indicates whether the matrix is unit diagonal.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.TriangularInvert(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
      <summary>
        <para>
            Computes the inverse of a real upper or lower triangular
            matrix A.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </pre>
      </param>
      <param name="diag">
        <pre>
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            On entry, the triangular matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of the array A contains
            the upper triangular matrix, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of the array A contains
            the lower triangular matrix, and the strictly upper
            triangular part of A is not referenced.  If DIAG = 'U', the
            diagonal elements of A are also not referenced and are
            assumed to be 1.
            On exit, the (triangular) inverse of the original matrix, in
            the same storage format.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0: successful exit
            &lt; 0: if <paramref name="info" /> = -i, the i-th argument had an illegal value
            &gt; 0: if <paramref name="info" /> = i, A(i,i) is exactly zero.  The triangular
                 matrix is singular and its inverse can not be computed.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.TriangularSolve(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
      <summary>
            Solves a complex triangular system of equations.
            </summary>
      <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle" /> value that indicates whether the matrix is upper
            or lower triangular.</param>
      <param name="trans">A <see cref="T:Extreme.Mathematics.TransposeOperation" /> value that indicates if the matrix should be transposed or not.</param>
      <param name="diag">A <see cref="T:Extreme.Mathematics.MatrixDiagonal" /> value that indicates whether the matrix is unit diagonal.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="nrhs">The number of right hand sides.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <param name="b">A complex array that contains the components of the right-hand side(s).</param>
      <param name="info">On return, indicates error conditions.</param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.TriangularSolve(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
      <summary>
        <para>
            Solves a triangular system of the form
               A * X = B  or  A<sup>T</sup> * X = B,
            where A is a triangular matrix of order N, and B is an N-by-NRHS
            matrix.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </pre>
      </param>
      <param name="trans">
        <pre>
            Specifies the form of the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A<sup>T</sup> * X = B  (Transpose)
            = 'C':  A<sup>H</sup> * X = B  (Conjugate transpose = Transpose)
            </pre>
      </param>
      <param name="diag">
        <pre>
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="nrhs">
        <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            The triangular matrix A.  If UPLO = 'U', the leading N-by-N
            upper triangular part of the array A contains the upper
            triangular matrix, and the strictly lower triangular part of
            A is not referenced.  If UPLO = 'L', the leading N-by-N lower
            triangular part of the array A contains the lower triangular
            matrix, and the strictly upper triangular part of A is not
            referenced.  If DIAG = 'U', the diagonal elements of A are
            also not referenced and are assumed to be 1.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,N).
            </pre>
      </param>
      <param name="b">
        <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, if <paramref name="info" /> = 0, the solution matrix X.
            </pre>
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,N).
            </pre>
      </param>
      <param name="info">
        <pre>
          <paramref name="info" /> is INTEGER
            = 0:  successful exit
            &lt; 0: if <paramref name="info" /> = -i, the i-th argument had an illegal value
            &gt; 0: if <paramref name="info" /> = i, the i-th diagonal element of A is zero,
                 indicating that the matrix is singular and the solutions
                 X have not been computed.
            </pre>
      </param>
    </member>
    <member name="T:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1">
      <summary>
            Implements the BLAS (Basic Linear Algebra Subroutines) for
            generic element types.
            </summary>
      <typeparam name="T">The element type of the arrays.</typeparam>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.AbsoluteMaxIndex(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Finds the index of element having max.</para>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.AbsoluteMaxIndex(System.Int32,Extreme.Collections.ArraySlice{`0})">
      <summary>
        <para>
            Finds the index of element having max.</para>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.ApplyModifiedGivensRotation(System.Int32,Extreme.Collections.ArraySlice{`0},Extreme.Collections.ArraySlice{`0},`0[])">
      <summary>
        <para>
            THE MODIFIED GIVENS TRANSFORMATION, H, TO THE 2 BY N MATRIX
               (DX<sup>T</sup>) , WHERE **T INDICATES TRANSPOSE.</para>
      </summary>
      <param name="n">
        <pre>
            number of elements in input vector(s)
            </pre>
      </param>
      <param name="dx">
        <pre>
            Dimension N
            T precision vector with N elements
            </pre>
        <pre>
            storage spacing between elements of DX
            </pre>
      </param>
      <param name="dy">
        <pre>
            Dimension N
            T precision vector with N elements
            </pre>
        <pre>
            storage spacing between elements of DY
            </pre>
      </param>
      <param name="dparam">
        <pre>
            Dimension 5
            AM(1)=DFLAG
            RAM(2)=DH11
            ARAM(3)=DH21
            PARAM(4)=DH12
            DPARAM(5)=DH22
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandHermitianMultiplyAndAddInPlace(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs the matrix-vector  operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x and y are n element vectors and
            A is an n by n hermitian band matrix, with k super-diagonals.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the band matrix A is being supplied as
             follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    being supplied.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    being supplied.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry, K specifies the number of super-diagonals of the
             matrix A. K must satisfy  0 .le. K.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the hermitian matrix, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer the upper
             triangular part of a hermitian band matrix from conventional
             full matrix storage to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the hermitian matrix, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer the lower
             triangular part of a hermitian band matrix from conventional
             full matrix storage to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that the imaginary parts of the diagonal elements need
             not be set and are assumed to be zero.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is COMPLEX*16 array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is COMPLEX*16 array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the
             vector y. On exit, Y is overwritten by the updated vector y.
            </pre>
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandMultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               y := alpha*A*x + beta*y,   or   y := alpha*A<sup>T</sup>*x + beta*y,   or
               y := alpha*A<sup>H</sup>*x + beta*y,
            where alpha and beta are scalars, x and y are vectors and A is an
            m by n band matrix, with kl sub-diagonals and ku super-diagonals.</para>
      </summary>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
                TRANS = 'T' or 't'   y := alpha*A<sup>T</sup>*x + beta*y.
                TRANS = 'C' or 'c'   y := alpha*A<sup>H</sup>*x + beta*y.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="kl">
        <pre>
             On entry, KL specifies the number of sub-diagonals of the
             matrix A. KL must satisfy  0 .le. KL.
            </pre>
      </param>
      <param name="ku">
        <pre>
             On entry, KU specifies the number of super-diagonals of the
             matrix A. KU must satisfy  0 .le. KU.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry, the leading ( kl + ku + 1 ) by n part of the
             array A must contain the matrix of coefficients, supplied
             column by column, with the leading diagonal of the matrix in
             row ( ku + 1 ) of the array, the first super-diagonal
             starting at position 2 in row ku, the first sub-diagonal
             starting at position 1 in row ( ku + 2 ), and so on.
             Elements in the array A that do not correspond to elements
             in the band matrix (such as the top left ku by ku triangle)
             are not referenced.
             The following program segment will transfer a band matrix
             from conventional full matrix storage to band storage:
                   DO 20, J = 1, N
                      K = KU + 1 - J
                      DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL )
                         A( K + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( kl + ku + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is COMPLEX*16 array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is COMPLEX*16 array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry, the incremented array Y must contain the
             vector y. On exit, Y is overwritten by the updated vector y.
            </pre>
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandMultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{`0},Extreme.Collections.ArraySlice{`0},`0,Extreme.Collections.ArraySlice{`0})">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               y := alpha*A*x + beta*y,   or   y := alpha*A<sup>T</sup>*x + beta*y,
            where alpha and beta are scalars, x and y are vectors and A is an
            m by n band matrix, with kl sub-diagonals and ku super-diagonals.</para>
      </summary>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
                TRANS = 'T' or 't'   y := alpha*A<sup>T</sup>*x + beta*y.
                TRANS = 'C' or 'c'   y := alpha*A<sup>T</sup>*x + beta*y.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="kl">
        <pre>
             On entry, KL specifies the number of sub-diagonals of the
             matrix A. KL must satisfy  0 .le. KL.
            </pre>
      </param>
      <param name="ku">
        <pre>
             On entry, KU specifies the number of super-diagonals of the
             matrix A. KU must satisfy  0 .le. KU.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry, the leading ( kl + ku + 1 ) by n part of the
             array A must contain the matrix of coefficients, supplied
             column by column, with the leading diagonal of the matrix in
             row ( ku + 1 ) of the array, the first super-diagonal
             starting at position 2 in row ku, the first sub-diagonal
             starting at position 1 in row ( ku + 2 ), and so on.
             Elements in the array A that do not correspond to elements
             in the band matrix (such as the top left ku by ku triangle)
             are not referenced.
             The following program segment will transfer a band matrix
             from conventional full matrix storage to band storage:
                   DO 20, J = 1, N
                      K = KU + 1 - J
                      DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL )
                         A( K + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( kl + ku + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry, the incremented array Y must contain the
             vector y. On exit, Y is overwritten by the updated vector y.
            </pre>
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandSymmetricMultiplyAndAddInPlace(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{`0},Extreme.Collections.ArraySlice{`0},`0,Extreme.Collections.ArraySlice{`0})">
      <summary>
        <para>
            Performs the matrix-vector  operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x and y are n element vectors and
            A is an n by n symmetric band matrix, with k super-diagonals.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the band matrix A is being supplied as
             follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    being supplied.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    being supplied.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry, K specifies the number of super-diagonals of the
             matrix A. K must satisfy  0 .le. K.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the symmetric matrix, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer the upper
             triangular part of a symmetric band matrix from conventional
             full matrix storage to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the symmetric matrix, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer the lower
             triangular part of a symmetric band matrix from conventional
             full matrix storage to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the
             vector y. On exit, Y is overwritten by the updated vector y.
            </pre>
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandTriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,   or   x := A<sup>H</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular band matrix, with ( k + 1 ) diagonals.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>H</sup>*x.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with UPLO = 'U' or 'u', K specifies the number of
             super-diagonals of the matrix A.
             On entry with UPLO = 'L' or 'l', K specifies the number of
             sub-diagonals of the matrix A.
             K must satisfy  0 .le. K.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer an upper
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer a lower
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that when DIAG = 'U' or 'u' the elements of the array A
             corresponding to the diagonal elements of the matrix are not
             referenced, but are assumed to be unity.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is (input/output) COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandTriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.ArraySlice{`0})">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular band matrix, with ( k + 1 ) diagonals.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>T</sup>*x.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with UPLO = 'U' or 'u', K specifies the number of
             super-diagonals of the matrix A.
             On entry with UPLO = 'L' or 'l', K specifies the number of
             sub-diagonals of the matrix A.
             K must satisfy  0 .le. K.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer an upper
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer a lower
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that when DIAG = 'U' or 'u' the elements of the array A
             corresponding to the diagonal elements of the matrix are not
             referenced, but are assumed to be unity.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandTriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,   or   A<sup>H</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular band matrix, with ( k + 1 )
            diagonals.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>H</sup>*x = b.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with UPLO = 'U' or 'u', K specifies the number of
             super-diagonals of the matrix A.
             On entry with UPLO = 'L' or 'l', K specifies the number of
             sub-diagonals of the matrix A.
             K must satisfy  0 .le. K.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer an upper
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer a lower
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that when DIAG = 'U' or 'u' the elements of the array A
             corresponding to the diagonal elements of the matrix are not
             referenced, but are assumed to be unity.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandTriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.ArraySlice{`0})">
      <summary>
        <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular band matrix, with ( k + 1 )
            diagonals.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>T</sup>*x = b.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with UPLO = 'U' or 'u', K specifies the number of
             super-diagonals of the matrix A.
             On entry with UPLO = 'L' or 'l', K specifies the number of
             sub-diagonals of the matrix A.
             K must satisfy  0 .le. K.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer an upper
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer a lower
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that when DIAG = 'U' or 'u' the elements of the array A
             corresponding to the diagonal elements of the matrix are not
             referenced, but are assumed to be unity.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.ComplexOneNorm(Extreme.Mathematics.Complex{`0})">
      <summary>
        <para>
            Computes the sum of the absolute values of a complex number
            </para>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.ConjugateDotProduct(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Forms the dot product of a vector.</para>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.ConjugateRankUpdate(System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs the rank 1 operation
               A := alpha*x*y**H + A,
            where alpha is a scalar, x is an m element vector, y is an n element
            vector and A is an m by n matrix.</para>
      </summary>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( m - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the m
             element vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients. On exit, A is
             overwritten by the updated matrix.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Copy(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
            Copies the specified elements of a complex matrix.
            </summary>
      <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle" /> value that specifies which part of the matrix should be copied.</param>
      <param name="m">The number of rows of the matrices.</param>
      <param name="n">The number of columns of the matrices.</param>
      <param name="a">A complex array that contains the data for the source matrix.</param>
      <param name="b">A complex array that contains the data for the destination matrix.</param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Copy(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0})">
      <summary>
        <para>
            Copies all or part of a two-dimensional matrix A to another
            matrix B.</para>
      </summary>
      <param name="storedTriangle">
        <pre>
            Specifies the part of the matrix A to be copied to B.
            = 'U':      Upper triangular part
            = 'L':      Lower triangular part
            Otherwise:  All of the matrix A
            </pre>
      </param>
      <param name="m">
        <pre>
            The number of rows of the matrix A.  M &gt;= 0.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix A.  N &gt;= 0.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            The m by n matrix A.  If UPLO = 'U', only the upper triangle
            or trapezoid is accessed; if UPLO = 'L', only the lower
            triangle or trapezoid is accessed.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(1,M).
            </pre>
      </param>
      <param name="b">
        <pre>
            Dimension (LDB,N)
            On exit, B = A in the locations specified by UPLO.
            </pre>
        <pre>
            The leading dimension of the array B.  LDB &gt;= max(1,M).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Copy(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Copies a vector, x, to a vector, y.</para>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.CreateGivensRotation(Extreme.Mathematics.Complex{`0}@,Extreme.Mathematics.Complex{`0},`0@,Extreme.Mathematics.Complex{`0}@)">
      <summary>
        <para>
            Determines a complex Givens rotation.</para>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.CreateGivensRotation(`0@,`0@,`0@,`0@)">
      <summary>
        <para>
            Construct givens plane rotation.</para>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.CreateModifiedGivensRotation(`0@,`0@,`0@,`0,`0[])">
      <summary>
        <para>
            THE MODIFIED GIVENS TRANSFORMATION MATRIX H WHICH ZEROS
               THE SECOND COMPONENT OF THE 2-VECTOR  (DSQRT(DD1)*DX1,DSQRT(DD2)*&gt;    DY2)**T.</para>
      </summary>
      <param name="dd1">
        <pre></pre>
      </param>
      <param name="dd2">
        <pre></pre>
      </param>
      <param name="dx1">
        <pre></pre>
      </param>
      <param name="dy1">
        <pre></pre>
      </param>
      <param name="dparam">
        <pre>
            Dimension 5
            AM(1)=DFLAG
            RAM(2)=DH11
            ARAM(3)=DH21
            PARAM(4)=DH12
            DPARAM(5)=DH22
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.DotProduct(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Forms the dot product of two vectors.</para>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.DotProduct(System.Int32,Extreme.Collections.ArraySlice{`0},Extreme.Collections.ArraySlice{`0})">
      <summary>
        <para>
            Forms the dot product of two vectors.</para>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.FullMatrixNorm(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
            Computes the norm of a general rectangular matrix.
            </summary>
      <param name="norm">A <see cref="T:Extreme.Mathematics.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="m">The number of rows of the matrix.</param>
      <param name="n">The number of columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <returns>The norm of the matrix.</returns>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.FullMatrixNorm(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,Extreme.Collections.Array2D{`0})">
      <summary>
        <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            real matrix A.</para>
      </summary>
      <param name="norm">
        <pre>
            Specifies the value to be returned in DLANGE as described
            above.
            </pre>
      </param>
      <param name="m">
        <pre>
            The number of rows of the matrix A.  M &gt;= 0.  When M = 0,
            DLANGE is set to zero.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix A.  N &gt;= 0.  When N = 0,
            DLANGE is set to zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            The m by n matrix A.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(M,1).
            </pre>
      </param>
    </member>
    <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HasSharedDegreeOfParallelism">
      <summary>
            Indicates whether the degree of parallelism is a property that is shared
            across instances.
            </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
            Computes the norm of a Hermitian matrix.
            </summary>
      <param name="norm">A <see cref="T:Extreme.Mathematics.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle" /> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <returns>The norm of the matrix.</returns>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianMultiplyAndAddInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               C := alpha*A*B + beta*C,
            or
               C := alpha*B*A + beta*C,
            where alpha and beta are scalars, A is an hermitian matrix and  B and
            C are m by n matrices.</para>
      </summary>
      <param name="side">
        <pre>
             On entry,  SIDE  specifies whether  the  hermitian matrix  A
             appears on the  left or right  in the  operation as follows:
                SIDE = 'L' or 'l'   C := alpha*A*B + beta*C,
                SIDE = 'R' or 'r'   C := alpha*B*A + beta*C,
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of  the  hermitian  matrix   A  is  to  be
             referenced as follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of the
                                    hermitian matrix is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of the
                                    hermitian matrix is to be referenced.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry,  M  specifies the number of rows of the matrix  C.
             M  must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix C.
             N  must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, ka ), where ka is
             m  when  SIDE = 'L' or 'l'  and is n  otherwise.
             Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of
             the array  A  must contain the  hermitian matrix,  such that
             when  UPLO = 'U' or 'u', the leading m by m upper triangular
             part of the array  A  must contain the upper triangular part
             of the  hermitian matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  m by m  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  hermitian
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
             Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of
             the array  A  must contain the  hermitian matrix,  such that
             when  UPLO = 'U' or 'u', the leading n by n upper triangular
             part of the array  A  must contain the upper triangular part
             of the  hermitian matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  n by n  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  hermitian
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
             Note that the imaginary parts  of the diagonal elements need
             not be set, they are assumed to be zero.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the  calling (sub) program. When  SIDE = 'L' or 'l'  then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is COMPLEX*16 array of DIMENSION ( LDB, n ).
             Before entry, the leading  m by n part of the array  B  must
             contain the matrix B.
            </pre>
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is COMPLEX*16 array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n updated
             matrix.
            </pre>
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianMultiplyAndAddInPlace(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs the matrix-vector  operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x and y are n element vectors and
            A is an n by n hermitian matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the hermitian matrix and the strictly
             lower triangular part of A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the hermitian matrix and the strictly
             upper triangular part of A is not referenced.
             Note that the imaginary parts of the diagonal elements need
             not be set and are assumed to be zero.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y. On exit, Y is overwritten by the updated
             vector y.
            </pre>
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs one of the hermitian rank 2k operations
               C := alpha*A*B<sup>H</sup> + conjg( alpha )*B*A<sup>H</sup> + beta*C,
            or
               C := alpha*A<sup>H</sup>*B + conjg( alpha )*B<sup>H</sup>*A + beta*C,
            where  alpha and beta  are scalars with  beta  real,  C is an  n by n
            hermitian matrix and  A and B  are  n by k matrices in the first case
            and  k by n  matrices in the second case.</para>
      </summary>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'    C := alpha*A*B<sup>H</sup>          +
                                           conjg( alpha )*B*A<sup>H</sup> +
                                           beta*C.
                TRANS = 'C' or 'c'    C := alpha*A<sup>H</sup>*B          +
                                           conjg( alpha )*B<sup>H</sup>*A +
                                           beta*C.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns  of the  matrices  A and B,  and on  entry  with
             TRANS = 'C' or 'c',  K  specifies  the number of rows of the
             matrices  A and B.  K must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is COMPLEX*16 .
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is COMPLEX*16 array of DIMENSION ( LDB, kb ), where kb is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  k by n  part of the array  B  must contain  the
             matrix B.
            </pre>
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDB must be at least  max( 1, n ), otherwise  LDB must
             be at least  max( 1, k ).
             Unchanged on exit.
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION .
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is COMPLEX*16 array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  hermitian matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  hermitian matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set,  they are assumed to be zero,  and on exit they
             are set to zero.
            </pre>
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs one of the hermitian rank k operations
               C := alpha*A*A<sup>H</sup> + beta*C,
            or
               C := alpha*A<sup>H</sup>*A + beta*C,
            where  alpha and beta  are  real scalars,  C is an  n by n  hermitian
            matrix and  A  is an  n by k  matrix in the  first case and a  k by n
            matrix in the second case.</para>
      </summary>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   C := alpha*A*A<sup>H</sup> + beta*C.
                TRANS = 'C' or 'c'   C := alpha*A<sup>H</sup>*A + beta*C.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns   of  the   matrix   A,   and  on   entry   with
             TRANS = 'C' or 'c',  K  specifies  the number of rows of the
             matrix A.  K must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION .
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is COMPLEX*16 array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  hermitian matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  hermitian matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set,  they are assumed to be zero,  and on exit they
             are set to zero.
            </pre>
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs the hermitian rank 2 operation
               A := alpha*x*y**H + conjg( alpha )*y*x**H + A,
            where alpha is a scalar, x and y are n element vectors and A is an n
            by n hermitian matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the hermitian matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the hermitian matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set, they are assumed to be zero, and on exit they
             are set to zero.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,`0,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs the hermitian rank 1 operation
               A := alpha*x*x**H + A,
            where alpha is a real scalar, x is an n element vector and A is an
            n by n hermitian matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the hermitian matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the hermitian matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set, they are assumed to be zero, and on exit they
             are set to zero.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
    </member>
    <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MaxDegreeOfParallelism">
      <summary>
            Gets or sets the maximum degree of parallelism enabled by the instance.
            </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               C := alpha*op( A )*op( B ) + beta*C,
            where  op( X ) is one of
               op( X ) = X   or   op( X ) = X<sup>T</sup>   or   op( X ) = X<sup>H</sup>,
            alpha and beta are scalars, and A, B and C are matrices, with op( A )
            an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.</para>
      </summary>
      <param name="transa">
        <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n',  op( A ) = A.
                TRANSA = 'T' or 't',  op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c',  op( A ) = A<sup>H</sup>.
            </pre>
      </param>
      <param name="transb">
        <pre>
             On entry, TRANSB specifies the form of op( B ) to be used in
             the matrix multiplication as follows:
                TRANSB = 'N' or 'n',  op( B ) = B.
                TRANSB = 'T' or 't',  op( B ) = B<sup>T</sup>.
                TRANSB = 'C' or 'c',  op( B ) = B<sup>H</sup>.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry,  M  specifies  the number  of rows  of the  matrix
             op( A )  and of the  matrix  C.  M  must  be at least  zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N  specifies the number  of columns of the matrix
             op( B ) and the number of columns of the matrix C. N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry,  K  specifies  the number of columns of the matrix
             op( A ) and the number of rows of the matrix op( B ). K must
             be at least  zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
             Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by m  part of the array  A  must contain  the
             matrix A.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. When  TRANSA = 'N' or 'n' then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least  max( 1, k ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is COMPLEX*16 array of DIMENSION ( LDB, kb ), where kb is
             n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
             Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  n by k  part of the array  B  must contain  the
             matrix B.
            </pre>
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in the calling (sub) program. When  TRANSB = 'N' or 'n' then
             LDB must be at least  max( 1, k ), otherwise  LDB must be at
             least  max( 1, n ).
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is COMPLEX*16 array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n  matrix
             ( alpha*op( A )*op( B ) + beta*C ).
            </pre>
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},`0,Extreme.Collections.Array2D{`0})">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               C := alpha*op( A )*op( B ) + beta*C,
            where  op( X ) is one of
               op( X ) = X   or   op( X ) = X<sup>T</sup>,
            alpha and beta are scalars, and A, B and C are matrices, with op( A )
            an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.</para>
      </summary>
      <param name="transa">
        <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n',  op( A ) = A.
                TRANSA = 'T' or 't',  op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c',  op( A ) = A<sup>T</sup>.
            </pre>
      </param>
      <param name="transb">
        <pre>
             On entry, TRANSB specifies the form of op( B ) to be used in
             the matrix multiplication as follows:
                TRANSB = 'N' or 'n',  op( B ) = B.
                TRANSB = 'T' or 't',  op( B ) = B<sup>T</sup>.
                TRANSB = 'C' or 'c',  op( B ) = B<sup>T</sup>.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry,  M  specifies  the number  of rows  of the  matrix
             op( A )  and of the  matrix  C.  M  must  be at least  zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N  specifies the number  of columns of the matrix
             op( B ) and the number of columns of the matrix C. N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry,  K  specifies  the number of columns of the matrix
             op( A ) and the number of rows of the matrix op( B ). K must
             be at least  zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
             Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by m  part of the array  A  must contain  the
             matrix A.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. When  TRANSA = 'N' or 'n' then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least  max( 1, k ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
             n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
             Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  n by k  part of the array  B  must contain  the
             matrix B.
            </pre>
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in the calling (sub) program. When  TRANSB = 'N' or 'n' then
             LDB must be at least  max( 1, k ), otherwise  LDB must be at
             least  max( 1, n ).
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is DOUBLE PRECISION array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n  matrix
             ( alpha*op( A )*op( B ) + beta*C ).
            </pre>
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               y := alpha*A*x + beta*y,   or   y := alpha*A<sup>T</sup>*x + beta*y,   or
               y := alpha*A<sup>H</sup>*x + beta*y,
            where alpha and beta are scalars, x and y are vectors and A is an
            m by n matrix.</para>
      </summary>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
                TRANS = 'T' or 't'   y := alpha*A<sup>T</sup>*x + beta*y.
                TRANS = 'C' or 'c'   y := alpha*A<sup>H</sup>*x + beta*y.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is COMPLEX*16 array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is COMPLEX*16 array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry with BETA non-zero, the incremented array Y
             must contain the vector y. On exit, Y is overwritten by the
             updated vector y.
            </pre>
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{`0},Extreme.Collections.ArraySlice{`0},`0,Extreme.Collections.ArraySlice{`0})">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               y := alpha*A*x + beta*y,   or   y := alpha*A<sup>T</sup>*x + beta*y,
            where alpha and beta are scalars, x and y are vectors and A is an
            m by n matrix.</para>
      </summary>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
                TRANS = 'T' or 't'   y := alpha*A<sup>T</sup>*x + beta*y.
                TRANS = 'C' or 'c'   y := alpha*A<sup>T</sup>*x + beta*y.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry with BETA non-zero, the incremented array Y
             must contain the vector y. On exit, Y is overwritten by the
             updated vector y.
            </pre>
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyAndAddInPlace(System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Constant times a vector plus a vector.</para>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyAndAddInPlace(System.Int32,`0,Extreme.Collections.ArraySlice{`0},Extreme.Collections.ArraySlice{`0})">
      <summary>
        <para>
            Constant times a vector plus a vector.</para>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyInPlace(System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Scales a vector by a constant.</para>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyInPlace(System.Int32,`0,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Scales a vector by a constant.</para>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyInPlace(System.Int32,`0,Extreme.Collections.ArraySlice{`0})">
      <summary>
        <para>
            Scales a vector by a constant.</para>
      </summary>
    </member>
    <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Name">
      <summary>
            Gets the name of the implementation.
            </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.OneNorm(System.Int32,Extreme.Collections.ArraySlice{`0})">
      <summary>
        <para>
            Takes the sum of the absolute values.</para>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedHermitianMultiplyAndAddInPlace(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs the matrix-vector operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x and y are n element vectors and
            A is an n by n hermitian matrix, supplied in packed form.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the matrix A is supplied in the packed
             array AP as follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    supplied in AP.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    supplied in AP.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="ap">
        <pre>
            AP is COMPLEX*16 array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with UPLO = 'U' or 'u', the array AP must
             contain the upper triangular part of the hermitian matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
             and a( 2, 2 ) respectively, and so on.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular part of the hermitian matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
             and a( 3, 1 ) respectively, and so on.
             Note that the imaginary parts of the diagonal elements need
             not be set and are assumed to be zero.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y. On exit, Y is overwritten by the updated
             vector y.
            </pre>
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedHermitianRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs the hermitian rank 2 operation
               A := alpha*x*y**H + conjg( alpha )*y*x**H + A,
            where alpha is a scalar, x and y are n element vectors and A is an
            n by n hermitian matrix, supplied in packed form.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the matrix A is supplied in the packed
             array AP as follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    supplied in AP.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    supplied in AP.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="ap">
        <pre>
            AP is COMPLEX*16 array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with  UPLO = 'U' or 'u', the array AP must
             contain the upper triangular part of the hermitian matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
             and a( 2, 2 ) respectively, and so on. On exit, the array
             AP is overwritten by the upper triangular part of the
             updated matrix.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular part of the hermitian matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
             and a( 3, 1 ) respectively, and so on. On exit, the array
             AP is overwritten by the lower triangular part of the
             updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set, they are assumed to be zero, and on exit they
             are set to zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedHermitianRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,`0,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs the hermitian rank 1 operation
               A := alpha*x*x**H + A,
            where alpha is a real scalar, x is an n element vector and A is an
            n by n hermitian matrix, supplied in packed form.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the matrix A is supplied in the packed
             array AP as follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    supplied in AP.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    supplied in AP.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="ap">
        <pre>
            AP is COMPLEX*16 array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with  UPLO = 'U' or 'u', the array AP must
             contain the upper triangular part of the hermitian matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
             and a( 2, 2 ) respectively, and so on. On exit, the array
             AP is overwritten by the upper triangular part of the
             updated matrix.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular part of the hermitian matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
             and a( 3, 1 ) respectively, and so on. On exit, the array
             AP is overwritten by the lower triangular part of the
             updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set, they are assumed to be zero, and on exit they
             are set to zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedSymmetricMultiplyAndAddInPlace(Extreme.Mathematics.MatrixTriangle,System.Int32,`0,Extreme.Collections.Array1D{`0},Extreme.Collections.ArraySlice{`0},`0,Extreme.Collections.ArraySlice{`0})">
      <summary>
        <para>
            Performs the matrix-vector operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x and y are n element vectors and
            A is an n by n symmetric matrix, supplied in packed form.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the matrix A is supplied in the packed
             array AP as follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    supplied in AP.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    supplied in AP.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="ap">
        <pre>
            AP is DOUBLE PRECISION array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with UPLO = 'U' or 'u', the array AP must
             contain the upper triangular part of the symmetric matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
             and a( 2, 2 ) respectively, and so on.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular part of the symmetric matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
             and a( 3, 1 ) respectively, and so on.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y. On exit, Y is overwritten by the updated
             vector y.
            </pre>
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedSymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,`0,Extreme.Collections.ArraySlice{`0},Extreme.Collections.Array1D{`0})">
      <summary>
        <para>
            Performs the symmetric rank 1 operation
               A := alpha*x*x**T + A,
            where alpha is a real scalar, x is an n element vector and A is an
            n by n symmetric matrix, supplied in packed form.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the matrix A is supplied in the packed
             array AP as follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    supplied in AP.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    supplied in AP.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="ap">
        <pre>
            AP is DOUBLE PRECISION array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with  UPLO = 'U' or 'u', the array AP must
             contain the upper triangular part of the symmetric matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
             and a( 2, 2 ) respectively, and so on. On exit, the array
             AP is overwritten by the upper triangular part of the
             updated matrix.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular part of the symmetric matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
             and a( 3, 1 ) respectively, and so on. On exit, the array
             AP is overwritten by the lower triangular part of the
             updated matrix.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedSymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,`0,Extreme.Collections.ArraySlice{`0},Extreme.Collections.ArraySlice{`0},Extreme.Collections.Array1D{`0})">
      <summary>
        <para>
            Performs the symmetric rank 2 operation
               A := alpha*x*y**T + alpha*y*x**T + A,
            where alpha is a scalar, x and y are n element vectors and A is an
            n by n symmetric matrix, supplied in packed form.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the matrix A is supplied in the packed
             array AP as follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    supplied in AP.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    supplied in AP.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="ap">
        <pre>
            AP is DOUBLE PRECISION array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with  UPLO = 'U' or 'u', the array AP must
             contain the upper triangular part of the symmetric matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
             and a( 2, 2 ) respectively, and so on. On exit, the array
             AP is overwritten by the upper triangular part of the
             updated matrix.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular part of the symmetric matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
             and a( 3, 1 ) respectively, and so on. On exit, the array
             AP is overwritten by the lower triangular part of the
             updated matrix.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedTriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,   or   x := A<sup>H</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular matrix, supplied in packed form.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>H</sup>*x.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="ap">
        <pre>
            AP is COMPLEX*16 array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with  UPLO = 'U' or 'u', the array AP must
             contain the upper triangular matrix packed sequentially,
             column by column, so that AP( 1 ) contains a( 1, 1 ),
             AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
             respectively, and so on.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular matrix packed sequentially,
             column by column, so that AP( 1 ) contains a( 1, 1 ),
             AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
             respectively, and so on.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced, but are assumed to be unity.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is (input/output) COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedTriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.ArraySlice{`0})">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular matrix, supplied in packed form.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>T</sup>*x.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="ap">
        <pre>
            AP is DOUBLE PRECISION array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with  UPLO = 'U' or 'u', the array AP must
             contain the upper triangular matrix packed sequentially,
             column by column, so that AP( 1 ) contains a( 1, 1 ),
             AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
             respectively, and so on.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular matrix packed sequentially,
             column by column, so that AP( 1 ) contains a( 1, 1 ),
             AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
             respectively, and so on.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced, but are assumed to be unity.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedTriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,   or   A<sup>H</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular matrix, supplied in packed form.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>H</sup>*x = b.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="ap">
        <pre>
            AP is COMPLEX*16 array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with  UPLO = 'U' or 'u', the array AP must
             contain the upper triangular matrix packed sequentially,
             column by column, so that AP( 1 ) contains a( 1, 1 ),
             AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
             respectively, and so on.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular matrix packed sequentially,
             column by column, so that AP( 1 ) contains a( 1, 1 ),
             AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
             respectively, and so on.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced, but are assumed to be unity.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedTriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.ArraySlice{`0})">
      <summary>
        <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular matrix, supplied in packed form.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>T</sup>*x = b.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="ap">
        <pre>
            AP is DOUBLE PRECISION array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with  UPLO = 'U' or 'u', the array AP must
             contain the upper triangular matrix packed sequentially,
             column by column, so that AP( 1 ) contains a( 1, 1 ),
             AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
             respectively, and so on.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular matrix packed sequentially,
             column by column, so that AP( 1 ) contains a( 1, 1 ),
             AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
             respectively, and so on.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced, but are assumed to be unity.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
    </member>
    <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Platform">
      <summary>
            Gets the processor architecture supported by the implementation.
            </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.RankUpdate(System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs the rank 1 operation
               A := alpha*x*y**T + A,
            where alpha is a scalar, x is an m element vector, y is an n element
            vector and A is an m by n matrix.</para>
      </summary>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( m - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the m
             element vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients. On exit, A is
             overwritten by the updated matrix.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.RankUpdate(System.Int32,System.Int32,`0,Extreme.Collections.ArraySlice{`0},Extreme.Collections.ArraySlice{`0},Extreme.Collections.Array2D{`0})">
      <summary>
        <para>
            Performs the rank 1 operation
               A := alpha*x*y**T + A,
            where alpha is a scalar, x is an m element vector, y is an n element
            vector and A is an m by n matrix.</para>
      </summary>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( m - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the m
             element vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients. On exit, A is
             overwritten by the updated matrix.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.RealOneNorm(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Takes the sum of the absolute values.</para>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Rotate(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},`0,`0)">
      <summary>
        <para>
            A plane rotation, where the cos and sin (c and s) are real
            and the vectors cx and cy are complex.</para>
      </summary>
      <param name="n">
        <pre>
             On entry, N specifies the order of the vectors cx and cy.
             N must be at least zero.
            </pre>
      </param>
      <param name="cx">
        <pre>
            CX is COMPLEX*16 array, dimension at least
             ( 1 + ( N - 1 )*abs( INCX ) ).
             Before entry, the incremented array CX must contain the n
             element vector cx. On exit, CX is overwritten by the updated
             vector cx.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             CX. INCX must not be zero.
            </pre>
      </param>
      <param name="cy">
        <pre>
            CY is COMPLEX*16 array, dimension at least
             ( 1 + ( N - 1 )*abs( INCY ) ).
             Before entry, the incremented array CY must contain the n
             element vector cy. On exit, CY is overwritten by the updated
             vector cy.
            </pre>
        <pre>
             On entry, INCY specifies the increment for the elements of
             CY. INCY must not be zero.
            </pre>
      </param>
      <param name="c">
        <pre>
             On entry, C specifies the cosine, cos.
            </pre>
      </param>
      <param name="s">
        <pre>
             On entry, S specifies the sine, sin.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Rotate(System.Int32,Extreme.Collections.ArraySlice{`0},Extreme.Collections.ArraySlice{`0},`0,`0)">
      <summary>
        <para>
            Applies a plane rotation.</para>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Swap(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Interchanges two vectors.</para>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Swap(System.Int32,Extreme.Collections.ArraySlice{`0},Extreme.Collections.ArraySlice{`0})">
      <summary>
        <para>
            Two vectors.</para>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
            Computes the norm of a symmetric matrix.
            </summary>
      <param name="norm">A <see cref="T:Extreme.Mathematics.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle" /> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
      <param name="n">The number of rows and columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <returns>The norm of the matrix.</returns>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0})">
      <summary>
        <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            real symmetric matrix A.</para>
      </summary>
      <param name="norm">
        <pre>
            Specifies the value to be returned in DLANSY as described
            above.
            </pre>
      </param>
      <param name="storedTriangle">
        <pre>
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is to be referenced.
            = 'U':  Upper triangular part of A is referenced
            = 'L':  Lower triangular part of A is referenced
            </pre>
      </param>
      <param name="n">
        <pre>
            The order of the matrix A.  N &gt;= 0.  When N = 0, DLANSY is
            set to zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            The symmetric matrix A.  If UPLO = 'U', the leading n by n
            upper triangular part of A contains the upper triangular part
            of the matrix A, and the strictly lower triangular part of A
            is not referenced.  If UPLO = 'L', the leading n by n lower
            triangular part of A contains the lower triangular part of
            the matrix A, and the strictly upper triangular part of A is
            not referenced.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(N,1).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricMultiplyAndAddInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               C := alpha*A*B + beta*C,
            or
               C := alpha*B*A + beta*C,
            where  alpha and beta are scalars, A is a symmetric matrix and  B and
            C are m by n matrices.</para>
      </summary>
      <param name="side">
        <pre>
             On entry,  SIDE  specifies whether  the  symmetric matrix  A
             appears on the  left or right  in the  operation as follows:
                SIDE = 'L' or 'l'   C := alpha*A*B + beta*C,
                SIDE = 'R' or 'r'   C := alpha*B*A + beta*C,
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of  the  symmetric  matrix   A  is  to  be
             referenced as follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of the
                                    symmetric matrix is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of the
                                    symmetric matrix is to be referenced.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry,  M  specifies the number of rows of the matrix  C.
             M  must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix C.
             N  must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, ka ), where ka is
             m  when  SIDE = 'L' or 'l'  and is n  otherwise.
             Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of
             the array  A  must contain the  symmetric matrix,  such that
             when  UPLO = 'U' or 'u', the leading m by m upper triangular
             part of the array  A  must contain the upper triangular part
             of the  symmetric matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  m by m  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  symmetric
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
             Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of
             the array  A  must contain the  symmetric matrix,  such that
             when  UPLO = 'U' or 'u', the leading n by n upper triangular
             part of the array  A  must contain the upper triangular part
             of the  symmetric matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  n by n  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  symmetric
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the  calling (sub) program. When  SIDE = 'L' or 'l'  then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is COMPLEX*16 array of DIMENSION ( LDB, n ).
             Before entry, the leading  m by n part of the array  B  must
             contain the matrix B.
            </pre>
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is COMPLEX*16 array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n updated
             matrix.
            </pre>
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricMultiplyAndAddInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},`0,Extreme.Collections.Array2D{`0})">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               C := alpha*A*B + beta*C,
            or
               C := alpha*B*A + beta*C,
            where alpha and beta are scalars,  A is a symmetric matrix and  B and
            C are  m by n matrices.</para>
      </summary>
      <param name="side">
        <pre>
             On entry,  SIDE  specifies whether  the  symmetric matrix  A
             appears on the  left or right  in the  operation as follows:
                SIDE = 'L' or 'l'   C := alpha*A*B + beta*C,
                SIDE = 'R' or 'r'   C := alpha*B*A + beta*C,
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of  the  symmetric  matrix   A  is  to  be
             referenced as follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of the
                                    symmetric matrix is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of the
                                    symmetric matrix is to be referenced.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry,  M  specifies the number of rows of the matrix  C.
             M  must be at least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of the matrix C.
             N  must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             m  when  SIDE = 'L' or 'l'  and is  n otherwise.
             Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of
             the array  A  must contain the  symmetric matrix,  such that
             when  UPLO = 'U' or 'u', the leading m by m upper triangular
             part of the array  A  must contain the upper triangular part
             of the  symmetric matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  m by m  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  symmetric
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
             Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of
             the array  A  must contain the  symmetric matrix,  such that
             when  UPLO = 'U' or 'u', the leading n by n upper triangular
             part of the array  A  must contain the upper triangular part
             of the  symmetric matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  n by n  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  symmetric
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least  max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, n ).
             Before entry, the leading  m by n part of the array  B  must
             contain the matrix B.
            </pre>
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is DOUBLE PRECISION array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n updated
             matrix.
            </pre>
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricMultiplyAndAddInPlace(Extreme.Mathematics.MatrixTriangle,System.Int32,`0,Extreme.Collections.Array2D{`0},Extreme.Collections.ArraySlice{`0},`0,Extreme.Collections.ArraySlice{`0})">
      <summary>
        <para>
            Performs the matrix-vector  operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x and y are n element vectors and
            A is an n by n symmetric matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the symmetric matrix and the strictly
             lower triangular part of A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the symmetric matrix and the strictly
             upper triangular part of A is not referenced.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y. On exit, Y is overwritten by the updated
             vector y.
            </pre>
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs one of the symmetric rank 2k operations
               C := alpha*A*B<sup>T</sup> + alpha*B*A<sup>T</sup> + beta*C,
            or
               C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A + beta*C,
            where  alpha and beta  are scalars,  C is an  n by n symmetric matrix
            and  A and B  are  n by k  matrices  in the  first  case  and  k by n
            matrices in the second case.</para>
      </summary>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'    C := alpha*A*B<sup>T</sup> + alpha*B*A<sup>T</sup> +
                                           beta*C.
                TRANS = 'T' or 't'    C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A +
                                           beta*C.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns  of the  matrices  A and B,  and on  entry  with
             TRANS = 'T' or 't',  K  specifies  the number of rows of the
             matrices  A and B.  K must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is COMPLEX*16 array of DIMENSION ( LDB, kb ), where kb is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  k by n  part of the array  B  must contain  the
             matrix B.
            </pre>
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDB must be at least  max( 1, n ), otherwise  LDB must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is COMPLEX*16 array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs one of the symmetric rank k operations
               C := alpha*A*A<sup>T</sup> + beta*C,
            or
               C := alpha*A<sup>T</sup>*A + beta*C,
            where  alpha and beta  are scalars,  C is an  n by n symmetric matrix
            and  A  is an  n by k  matrix in the first case and a  k by n  matrix
            in the second case.</para>
      </summary>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   C := alpha*A*A<sup>T</sup> + beta*C.
                TRANS = 'T' or 't'   C := alpha*A<sup>T</sup>*A + beta*C.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns   of  the   matrix   A,   and  on   entry   with
             TRANS = 'T' or 't',  K  specifies  the number of rows of the
             matrix A.  K must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="beta">
        <pre>
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is COMPLEX*16 array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},`0,Extreme.Collections.Array2D{`0})">
      <summary>
        <para>
            Performs one of the symmetric rank 2k operations
               C := alpha*A*B<sup>T</sup> + alpha*B*A<sup>T</sup> + beta*C,
            or
               C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A + beta*C,
            where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
            and  A and B  are  n by k  matrices  in the  first  case  and  k by n
            matrices in the second case.</para>
      </summary>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   C := alpha*A*B<sup>T</sup> + alpha*B*A<sup>T</sup> +
                                          beta*C.
                TRANS = 'T' or 't'   C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A +
                                          beta*C.
                TRANS = 'C' or 'c'   C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A +
                                          beta*C.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns  of the  matrices  A and B,  and on  entry  with
             TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number
             of rows of the matrices  A and B.  K must be at least  zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  k by n  part of the array  B  must contain  the
             matrix B.
            </pre>
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDB must be at least  max( 1, n ), otherwise  LDB must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is DOUBLE PRECISION array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{`0},`0,Extreme.Collections.Array2D{`0})">
      <summary>
        <para>
            Performs one of the symmetric rank k operations
               C := alpha*A*A<sup>T</sup> + beta*C,
            or
               C := alpha*A<sup>T</sup>*A + beta*C,
            where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
            and  A  is an  n by k  matrix in the first case and a  k by n  matrix
            in the second case.</para>
      </summary>
      <param name="uplo">
        <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   C := alpha*A*A<sup>T</sup> + beta*C.
                TRANS = 'T' or 't'   C := alpha*A<sup>T</sup>*A + beta*C.
                TRANS = 'C' or 'c'   C := alpha*A<sup>T</sup>*A + beta*C.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
      </param>
      <param name="k">
        <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns   of  the   matrix   A,   and  on   entry   with
             TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number
             of rows of the matrix  A.  K must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
      </param>
      <param name="beta">
        <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
            </pre>
      </param>
      <param name="c">
        <pre>
            C is DOUBLE PRECISION array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
        <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,`0,Extreme.Collections.ArraySlice{`0},Extreme.Collections.Array2D{`0})">
      <summary>
        <para>
            Performs the symmetric rank 1 operation
               A := alpha*x*x**T + A,
            where alpha is a real scalar, x is an n element vector and A is an
            n by n symmetric matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the symmetric matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the symmetric matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,`0,Extreme.Collections.ArraySlice{`0},Extreme.Collections.ArraySlice{`0},Extreme.Collections.Array2D{`0})">
      <summary>
        <para>
            Performs the symmetric rank 2 operation
               A := alpha*x*y**T + alpha*y*x**T + A,
            where alpha is a scalar, x and y are n element vectors and A is an n
            by n symmetric matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
      <param name="y">
        <pre>
            Y is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
        <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the symmetric matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the symmetric matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
            Computes the norm of a triangular matrix.
            </summary>
      <param name="norm">A <see cref="T:Extreme.Mathematics.MatrixNorm" /> that specifies the type of norm to compute.</param>
      <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle" /> value that specifies whether the
            matrix is upper or lower triangular.</param>
      <param name="diag">A <see cref="T:Extreme.Mathematics.MatrixDiagonal" /> value that indicates whether the diagonal
            elements are all equal to one.</param>
      <param name="m">The number of rows of the matrix.</param>
      <param name="n">The number of columns of the matrix.</param>
      <param name="a">A complex array that contains the elements of the matrix.</param>
      <returns>The norm of the matrix.</returns>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{`0})">
      <summary>
        <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            trapezoidal or triangular matrix A.</para>
      </summary>
      <param name="norm">
        <pre>
            Specifies the value to be returned in DLANTR as described
            above.
            </pre>
      </param>
      <param name="storedTriangle">
        <pre>
            Specifies whether the matrix A is upper or lower trapezoidal.
            = 'U':  Upper trapezoidal
            = 'L':  Lower trapezoidal
            Note that A is triangular instead of trapezoidal if M = N.
            </pre>
      </param>
      <param name="diag">
        <pre>
            Specifies whether or not the matrix A has unit diagonal.
            = 'N':  Non-unit diagonal
            = 'U':  Unit diagonal
            </pre>
      </param>
      <param name="m">
        <pre>
            The number of rows of the matrix A.  M &gt;= 0, and if
            UPLO = 'U', M &lt;= N.  When M = 0, DLANTR is set to zero.
            </pre>
      </param>
      <param name="n">
        <pre>
            The number of columns of the matrix A.  N &gt;= 0, and if
            UPLO = 'L', N &lt;= M.  When N = 0, DLANTR is set to zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            Dimension (LDA,N)
            The trapezoidal matrix A (A is triangular if M = N).
            If UPLO = 'U', the leading m by n upper trapezoidal part of
            the array A contains the upper trapezoidal matrix, and the
            strictly lower triangular part of A is not referenced.
            If UPLO = 'L', the leading m by n lower trapezoidal part of
            the array A contains the lower trapezoidal matrix, and the
            strictly upper triangular part of A is not referenced.  Note
            that when DIAG = 'U', the diagonal elements of A are not
            referenced and are assumed to be one.
            </pre>
        <pre>
            The leading dimension of the array A.  LDA &gt;= max(M,1).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularMultiplyInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               B := alpha*op( A )*B,   or   B := alpha*B*op( A )
            where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
            non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
               op( A ) = A   or   op( A ) = A<sup>T</sup>   or   op( A ) = A<sup>H</sup>.</para>
      </summary>
      <param name="side">
        <pre>
             On entry,  SIDE specifies whether  op( A ) multiplies B from
             the left or right as follows:
                SIDE = 'L' or 'l'   B := alpha*op( A )*B.
                SIDE = 'R' or 'r'   B := alpha*B*op( A ).
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="transa">
        <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n'   op( A ) = A.
                TRANSA = 'T' or 't'   op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c'   op( A ) = A<sup>H</sup>.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of B. M must be at
             least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, k ), where k is m
             when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is (input/output) COMPLEX*16 array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain the matrix  B,  and  on exit  is overwritten  by the
             transformed matrix.
            </pre>
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularMultiplyInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0})">
      <summary>
        <para>
            Performs one of the matrix-matrix operations
               B := alpha*op( A )*B,   or   B := alpha*B*op( A ),
            where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
            non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
               op( A ) = A   or   op( A ) = A<sup>T</sup>.</para>
      </summary>
      <param name="side">
        <pre>
             On entry,  SIDE specifies whether  op( A ) multiplies B from
             the left or right as follows:
                SIDE = 'L' or 'l'   B := alpha*op( A )*B.
                SIDE = 'R' or 'r'   B := alpha*B*op( A ).
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="transa">
        <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n'   op( A ) = A.
                TRANSA = 'T' or 't'   op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c'   op( A ) = A<sup>T</sup>.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of B. M must be at
             least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
            when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
            Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
            upper triangular part of the array  A must contain the upper
            triangular matrix  and the strictly lower triangular part of
            A is not referenced.
            Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
            lower triangular part of the array  A must contain the lower
            triangular matrix  and the strictly upper triangular part of
            A is not referenced.
            Note that when  DIAG = 'U' or 'u',  the diagonal elements of
            A  are not referenced either,  but are assumed to be  unity.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain the matrix  B,  and  on exit  is overwritten  by the
             transformed matrix.
            </pre>
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,   or   x := A<sup>H</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>H</sup>*x.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is (input/output) COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.ArraySlice{`0})">
      <summary>
        <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>T</sup>*x.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularSolveInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Solves one of the matrix equations
               op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
            where alpha is a scalar, X and B are m by n matrices, A is a unit, or
            non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
               op( A ) = A   or   op( A ) = A<sup>T</sup>   or   op( A ) = A<sup>H</sup>.</para>
      </summary>
      <param name="side">
        <pre>
             On entry, SIDE specifies whether op( A ) appears on the left
             or right of X as follows:
                SIDE = 'L' or 'l'   op( A )*X = alpha*B.
                SIDE = 'R' or 'r'   X*op( A ) = alpha*B.
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="transa">
        <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n'   op( A ) = A.
                TRANSA = 'T' or 't'   op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c'   op( A ) = A<sup>H</sup>.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of B. M must be at
             least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, k ),
             where k is m when SIDE = 'L' or 'l'
               and k is n when SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is COMPLEX*16 array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain  the  right-hand  side  matrix  B,  and  on exit  is
             overwritten by the solution matrix  X.
            </pre>
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularSolveInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0})">
      <summary>
        <para>
            Solves one of the matrix equations
               op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
            where alpha is a scalar, X and B are m by n matrices, A is a unit, or
            non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
               op( A ) = A   or   op( A ) = A<sup>T</sup>.</para>
      </summary>
      <param name="side">
        <pre>
             On entry, SIDE specifies whether op( A ) appears on the left
             or right of X as follows:
                SIDE = 'L' or 'l'   op( A )*X = alpha*B.
                SIDE = 'R' or 'r'   X*op( A ) = alpha*B.
            </pre>
      </param>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="transa">
        <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n'   op( A ) = A.
                TRANSA = 'T' or 't'   op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c'   op( A ) = A<sup>T</sup>.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="m">
        <pre>
             On entry, M specifies the number of rows of B. M must be at
             least zero.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
            </pre>
      </param>
      <param name="alpha">
        <pre>
            ALPHA is DOUBLE PRECISION.
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, k ),
             where k is m when SIDE = 'L' or 'l'
               and k is n when SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
            </pre>
      </param>
      <param name="b">
        <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain  the  right-hand  side  matrix  B,  and  on exit  is
             overwritten by the solution matrix  X.
            </pre>
        <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,   or   A<sup>H</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>H</sup>*x = b.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.ArraySlice{`0})">
      <summary>
        <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular matrix.</para>
      </summary>
      <param name="uplo">
        <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
      </param>
      <param name="trans">
        <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>T</sup>*x = b.
            </pre>
      </param>
      <param name="diag">
        <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
      </param>
      <param name="n">
        <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
      </param>
      <param name="a">
        <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
            </pre>
        <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
      </param>
      <param name="x">
        <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
        <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            2 LinearAlgebra routine.
            itten on 22-October-1986.
            ack Dongarra, Argonne National Lab.
            Jeremy Du Croz, Nag Central Office.
            Sven Hammarling, Nag Central Office.
            Richard Hanson, Sandia National Labs.
            </pre>
      </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TwoNorm(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
        <para>
          <pre>
            Returns the euclidean norm of a vector via the function
            name, so that
               DZNRM2 := sqrt( x**H*x )
            </pre>
        </para>
      </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TwoNorm(System.Int32,Extreme.Collections.ArraySlice{`0})">
      <summary>
        <para>
          <pre>
            Returns the euclidean norm of a vector via the function
            name, so that
               DNRM2 := sqrt( x'*x )
            </pre>
        </para>
      </summary>
    </member>
    <member name="T:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1">
      <summary>
            Implements the sparse BLAS (Basic Linear Algebra Subroutines) for
            generic element types.
            </summary>
      <typeparam name="T">The element type of the arrays.</typeparam>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.#ctor">
      <summary>
            Constructs a new <see cref="T:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperations" /> object.
            </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.Complex{`0}[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
            Multiplies a dense vector by a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="k">The number of columns in the matrix <paramref name="a" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
      <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x" />.</param>
      <param name="beta">The scalar used to multiply <paramref name="y" />.
            </param>
      <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.
            </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.Complex{`0}[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
            Multiplies a matrix in compressed sparse column format with a dense matrix.
            </summary>
      <param name="transA"></param>
      <param name="m">The number of rows in the matrix A.</param>
      <param name="n">The number of columns in the matrix C.</param>
      <param name="k">The number of columns in the matric A.</param>
      <param name="alpha">The multiplier for the matrix product.</param>
      <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure" /> value that specifies the structural properties
            of the matrix A</param>
      <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle" /> value that specifies whether the
            upper or lower triangular part of the matrix is used.</param>
      <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal" /> value that specifies whether the
            diagonal of the sparse matrix contains all 1's.</param>
      <param name="a">A <see cref="T:System.Double" /> array that contains the values of the elements of the
            matrix A.</param>
      <param name="aRows">An integer array that contains the row indexes corresponding to the values in
            <paramref name="a" />.</param>
      <param name="aPointerB">An integer array that specifies the index into <paramref name="a" /> and
            <paramref name="aRows" /> of the first element of each column.</param>
      <param name="aPointerE">An integer array that specifies the index into <paramref name="a" /> and
            <paramref name="aRows" /> past the last element of each column.</param>
      <param name="b">A <see cref="T:System.Double" /> array that contains the components of the dense matrix.</param>
      <param name="beta">Multiplier for the matrix C.</param>
      <param name="c">A <see cref="T:System.Double" /> array that contains the components of the (dense) result matrix.</param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,`0,Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,`0[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.Array2D{`0},`0,Extreme.Collections.Array2D{`0})">
      <summary>
            Multiplies a matrix in compressed sparse column format with a dense matrix.
            </summary>
      <param name="transA"></param>
      <param name="m">The number of rows in the matrix A.</param>
      <param name="n">The number of columns in the matrix C.</param>
      <param name="k">The number of columns in the matric A.</param>
      <param name="alpha">The multiplier for the matrix product.</param>
      <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure" /> value that specifies the structural properties
            of the matrix A</param>
      <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle" /> value that specifies whether the
            upper or lower triangular part of the matrix is used.</param>
      <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal" /> value that specifies whether the
            diagonal of the sparse matrix contains all 1's.</param>
      <param name="a">A <see cref="T:System.Double" /> array that contains the values of the elements of the
            matrix A.</param>
      <param name="aRows">An integer array that contains the row indexes corresponding to the values in
            <paramref name="a" />.</param>
      <param name="aPointerB">An integer array that specifies the index into <paramref name="a" /> and
            <paramref name="aRows" /> of the first element of each column.</param>
      <param name="aPointerE">An integer array that specifies the index into <paramref name="a" /> and
            <paramref name="aRows" /> past the last element of each column.</param>
      <param name="b">A <see cref="T:System.Double" /> array that contains the components of the dense matrix.</param>
      <param name="beta">Multiplier for the matrix C.</param>
      <param name="c">A <see cref="T:System.Double" /> array that contains the components of the (dense) result matrix.</param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,`0,Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,`0[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.ArraySlice{`0},`0,Extreme.Collections.ArraySlice{`0})">
      <summary>
            Multiplies a dense vector by a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="k">The number of columns in the matrix <paramref name="a" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
      <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x" />.</param>
      <param name="beta">The scalar used to multiply <paramref name="y" />.
            </param>
      <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.
            </param>
    </member>
    <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.Name">
      <summary>
            Gets the name of the implementation.
            </summary>
    </member>
    <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.Platform">
      <summary>
            Gets the processor architecture supported by the implementation.
            </summary>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.TriangularSolve(Extreme.Mathematics.TransposeOperation,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.Complex{`0}[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
      <summary>
            Solves for a dense vector for a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
      <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x" />.</param>
      <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.
            </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.TriangularSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.Complex{`0}[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
      <summary>
            Solves for a dense vector for a sparse matrix in compressed sparse column format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="n">The number of columns of the matrices <paramref name="b" /> and <paramref name="c" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
      <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="b">A two-dimensional array
            containing the elements of the right-hand side.</param>
      <param name="c">A two-dimensional array
            containing the elements of the solution.
            </param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.TriangularSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,`0,Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,`0[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0})">
      <summary></summary>
      <param name="transA"></param>
      <param name="m"></param>
      <param name="n"></param>
      <param name="alpha"></param>
      <param name="structure"></param>
      <param name="storedTriangle"></param>
      <param name="matrixDiagonal"></param>
      <param name="a"></param>
      <param name="aRows"></param>
      <param name="aPointerB"></param>
      <param name="aPointerE"></param>
      <param name="b"></param>
      <param name="c"></param>
    </member>
    <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.TriangularSolve(Extreme.Mathematics.TransposeOperation,System.Int32,`0,Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,`0[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.ArraySlice{`0},Extreme.Collections.ArraySlice{`0})">
      <summary>
            Solves for a dense vector for a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
      <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a" />.</param>
      <param name="m">The number of rows in the matrix <paramref name="a" />.</param>
      <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
      <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure" /> value that
            specifies the structure of the matrix.</param>
      <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle" />
            value that specifies whether the matrix is upper or lower triangular.</param>
      <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal" />
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
      <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
      <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a" />.</param>
      <param name="aPointerB">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="aPointerE">Integer array of length <paramref name="m" /> containing the 1-based
            indices into <paramref name="a" /> of the first component of each column.</param>
      <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x" />.</param>
      <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y" />.
            The elements of <paramref name="y" /> are overwritten with
            the result.
            </param>
    </member>
  </members>
</doc>